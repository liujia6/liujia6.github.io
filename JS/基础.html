<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.13" />
    <style>
      :root {
        --c-bg: #fff;
      }

      html.dark {
        --c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <link rel="icon" href="/favicon.ico"><title>基础 | 游离 の Blog</title><meta name="description" content="">
    <link rel="preload" href="/assets/style-DADYFlon.css" as="style"><link rel="stylesheet" href="/assets/style-DADYFlon.css">
    <link rel="modulepreload" href="/assets/app-BYS36vur.js"><link rel="modulepreload" href="/assets/基础.html-DTZlmurQ.js">
    <link rel="prefetch" href="/assets/index.html-C0vaV-Q8.js" as="script"><link rel="prefetch" href="/assets/Error.html-DGtk3Zv3.js" as="script"><link rel="prefetch" href="/assets/RXJS.html-CVbdZQUj.js" as="script"><link rel="prefetch" href="/assets/ts.html-DrUlVPgb.js" as="script"><link rel="prefetch" href="/assets/二进制.html-C-i_W_Ax.js" as="script"><link rel="prefetch" href="/assets/异步.html-CXoWjvEq.js" as="script"><link rel="prefetch" href="/assets/手写代码系列.html-DYyN_QPd.js" as="script"><link rel="prefetch" href="/assets/类型转换.html-d83awUSN.js" as="script"><link rel="prefetch" href="/assets/错误处理.html-C2Z6_gWS.js" as="script"><link rel="prefetch" href="/assets/Vuejs设计与实现.html-Dy0lDYCV.js" as="script"><link rel="prefetch" href="/assets/keep-alive.html-o2fFztot.js" as="script"><link rel="prefetch" href="/assets/key值.html-BJMIzNDi.js" as="script"><link rel="prefetch" href="/assets/vue2响应式原理.html-DfUKepU3.js" as="script"><link rel="prefetch" href="/assets/vue3新特性.html-B0UmK71G.js" as="script"><link rel="prefetch" href="/assets/vue使用总结.html-B67x6YND.js" as="script"><link rel="prefetch" href="/assets/vue命名方式.html-BeoAZz0b.js" as="script"><link rel="prefetch" href="/assets/ansible.html-g5jUWaJo.js" as="script"><link rel="prefetch" href="/assets/bash.html-CUdr2QiO.js" as="script"><link rel="prefetch" href="/assets/docker.html-BiZAo7Vb.js" as="script"><link rel="prefetch" href="/assets/gitlab-ci.html-BT1X7389.js" as="script"><link rel="prefetch" href="/assets/linux.html-DnVqCRUo.js" as="script"><link rel="prefetch" href="/assets/nginx.html-ZJgrTcee.js" as="script"><link rel="prefetch" href="/assets/ssh.html-D-umq8DH.js" as="script"><link rel="prefetch" href="/assets/CSS.html-DuUhO882.js" as="script"><link rel="prefetch" href="/assets/less_postcss.html-CpBPZYic.js" as="script"><link rel="prefetch" href="/assets/index.html-Bfu7LHWp.js" as="script"><link rel="prefetch" href="/assets/babel.html-xjItmTE0.js" as="script"><link rel="prefetch" href="/assets/git.html-BIrvJEk8.js" as="script"><link rel="prefetch" href="/assets/package.json.html-uzA7lmne.js" as="script"><link rel="prefetch" href="/assets/webpack.html-w6lxpkra.js" as="script"><link rel="prefetch" href="/assets/代码风格统一指南.html-DIYzqUog.js" as="script"><link rel="prefetch" href="/assets/模块化.html-CS9vE-BC.js" as="script"><link rel="prefetch" href="/assets/测试.html-DnuACrVv.js" as="script"><link rel="prefetch" href="/assets/OAuth2与微信登陆.html-BngLLKud.js" as="script"><link rel="prefetch" href="/assets/index.html-CPhXWsnK.js" as="script"><link rel="prefetch" href="/assets/微前端.html-Bm_Caomy.js" as="script"><link rel="prefetch" href="/assets/移动端适配.html-eP-Tt_qx.js" as="script"><link rel="prefetch" href="/assets/页面渲染探索和演进.html-VlyjKBV4.js" as="script"><link rel="prefetch" href="/assets/index.html-DkLNw5m9.js" as="script"><link rel="prefetch" href="/assets/a-life-of-a-pixel浏览器渲染.html-C1yQA908.js" as="script"><link rel="prefetch" href="/assets/layoutNG.html-CYgKIr5m.js" as="script"><link rel="prefetch" href="/assets/变化.html-DyUvd37t.js" as="script"><link rel="prefetch" href="/assets/浏览器架构.html-Bq4XR2w-.js" as="script"><link rel="prefetch" href="/assets/index.html-BYKO3Qh5.js" as="script"><link rel="prefetch" href="/assets/买卖股票.html-DYs8rL2X.js" as="script"><link rel="prefetch" href="/assets/二叉树.html-g4bDRvh5.js" as="script"><link rel="prefetch" href="/assets/其他构造类.html-ByBkbgg2.js" as="script"><link rel="prefetch" href="/assets/动态规划.html-DVc5fa60.js" as="script"><link rel="prefetch" href="/assets/十大排序.html-tlHWKIUm.js" as="script"><link rel="prefetch" href="/assets/双指针.html-BcNoNGcd.js" as="script"><link rel="prefetch" href="/assets/回溯.html-Cql3Rnbk.js" as="script"><link rel="prefetch" href="/assets/子串子序列系列.html-CA__4NJH.js" as="script"><link rel="prefetch" href="/assets/字符串.html-yrEGjRxz.js" as="script"><link rel="prefetch" href="/assets/排序相关.html-DKxakirD.js" as="script"><link rel="prefetch" href="/assets/数学.html-C7a3Xyu_.js" as="script"><link rel="prefetch" href="/assets/数组.html-BGcEXTkB.js" as="script"><link rel="prefetch" href="/assets/栈.html-RlJlyWup.js" as="script"><link rel="prefetch" href="/assets/背包.html-BpBkXWLX.js" as="script"><link rel="prefetch" href="/assets/链表.html-diPpfGxH.js" as="script"><link rel="prefetch" href="/assets/airbnb.html-Bj8kHMcG.js" as="script"><link rel="prefetch" href="/assets/plantuml.html-GuAU9e4n.js" as="script"><link rel="prefetch" href="/assets/函数式编程.html-C191Ha5X.js" as="script"><link rel="prefetch" href="/assets/架构整洁之道.html-6o2FOIRj.js" as="script"><link rel="prefetch" href="/assets/状态机.html-DnbSirk7.js" as="script"><link rel="prefetch" href="/assets/设计模式.html-BCVHmWuv.js" as="script"><link rel="prefetch" href="/assets/重构.html-DSK9uFIi.js" as="script"><link rel="prefetch" href="/assets/HTTP.html-BU-_wIYK.js" as="script"><link rel="prefetch" href="/assets/HTTP权威指南.html-CUVgiYBj.js" as="script"><link rel="prefetch" href="/assets/TCP-UDP.html-B8J0jf_y.js" as="script"><link rel="prefetch" href="/assets/grpc.html-VKbS4PfI.js" as="script"><link rel="prefetch" href="/assets/web状态存储.html-DfKQvwKu.js" as="script"><link rel="prefetch" href="/assets/网络基础.html-CDGeHHAD.js" as="script"><link rel="prefetch" href="/assets/web安全.html-C51FNuy6.js" as="script"><link rel="prefetch" href="/assets/UDP.html-Bmoo1LX-.js" as="script"><link rel="prefetch" href="/assets/404.html-qO4hmvmC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon"><!--[--><header class="vp-navbar"><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">游离 の Blog</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/liujia6/liujia6.github.io" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><button class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar"><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/liujia6/liujia6.github.io" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/JS/%E5%9F%BA%E7%A1%80.html" aria-label="基础"><!---->基础<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#作用域" aria-label="作用域"><!---->作用域<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#执行环境" aria-label="执行环境"><!---->执行环境<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#可执行代码" aria-label="可执行代码"><!---->可执行代码<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#活动对象" aria-label="活动对象"><!---->活动对象<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#执行上下文的生命周期" aria-label="执行上下文的生命周期"><!---->执行上下文的生命周期<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#闭包" aria-label="闭包"><!---->闭包<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#作用" aria-label="作用"><!---->作用<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#特性" aria-label="特性"><!---->特性<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#闭包在-chrome、引擎的应用" aria-label="闭包在 chrome、引擎的应用"><!---->闭包在 chrome、引擎的应用<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#彻底搞懂-this" aria-label="彻底搞懂 this"><!---->彻底搞懂 this<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#是什么" aria-label="是什么"><!---->是什么<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#进阶理解" aria-label="进阶理解"><!---->进阶理解<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#函数" aria-label="函数"><!---->函数<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#命名函数表达式-nfe" aria-label="命名函数表达式（NFE）"><!---->命名函数表达式（NFE）<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#new-function-语法" aria-label="&quot;new Function&quot; 语法"><!---->&quot;new Function&quot; 语法<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#惰性载入函数" aria-label="惰性载入函数"><!---->惰性载入函数<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#箭头函数" aria-label="箭头函数"><!---->箭头函数<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#轮询任务中-settimout-和-setinterval-以及-requestanimationframe-使用" aria-label="轮询任务中 setTimout 和 setInterval 以及 requestAnimationFrame 使用"><!---->轮询任务中 setTimout 和 setInterval 以及 requestAnimationFrame 使用<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#立即执行函数" aria-label="立即执行函数"><!---->立即执行函数<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#原型和原型链" aria-label="原型和原型链"><!---->原型和原型链<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#继承" aria-label="继承"><!---->继承<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#原型链继承" aria-label="原型链继承"><!---->原型链继承<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#构造函数继承" aria-label="构造函数继承"><!---->构造函数继承<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#组合继承" aria-label="组合继承"><!---->组合继承<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#原型式继承" aria-label="原型式继承"><!---->原型式继承<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#寄生式继承" aria-label="寄生式继承"><!---->寄生式继承<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#寄生组合继承" aria-label="寄生组合继承"><!---->寄生组合继承<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#进制转换" aria-label="进制转换"><!---->进制转换<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#堆栈的区别" aria-label="堆栈的区别"><!---->堆栈的区别<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#垃圾回收和定时器回调" aria-label="垃圾回收和定时器回调"><!---->垃圾回收和定时器回调<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#总结" aria-label="总结"><!---->总结<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#array-sort-的理解" aria-label="Array.sort()的理解"><!---->Array.sort()的理解<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#slice-substring-substr-的区别" aria-label="slice\substring\substr 的区别"><!---->slice\substring\substr 的区别<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#区别数组的方法" aria-label="区别数组的方法"><!---->区别数组的方法<!----></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/%E5%BC%82%E6%AD%A5.html" aria-label="异步"><!---->异步<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/Error.html" aria-label="/JS/Error.html"><!---->/JS/Error.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html" aria-label="错误处理的应用"><!---->错误处理的应用<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html" aria-label="JS 类型与转换"><!---->JS 类型与转换<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97.html" aria-label="手写代码"><!---->手写代码<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/ts.html" aria-label="/JS/ts.html"><!---->/JS/ts.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/JS/RXJS.html" aria-label="RXJS"><!---->RXJS<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/dev-ops/ssh.html" aria-label="ssh"><!---->ssh<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/dev-ops/linux.html" aria-label="linux 总结"><!---->linux 总结<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/dev-ops/nginx.html" aria-label="nginx"><!---->nginx<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/dev-ops/gitlab-ci.html" aria-label="/dev-ops/gitlab-ci.html"><!---->/dev-ops/gitlab-ci.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/dev-ops/ansible.html" aria-label="ansible"><!---->ansible<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/dev-ops/docker.html" aria-label="/dev-ops/docker.html"><!---->/dev-ops/docker.html<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html" aria-label="Vue 响应式原理"><!---->Vue 响应式原理<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/vue3%E6%96%B0%E7%89%B9%E6%80%A7.html" aria-label="vue3新特性"><!---->vue3新特性<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/key%E5%80%BC.html" aria-label="vue 中 key 值的作用"><!---->vue 中 key 值的作用<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/vue%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F.html" aria-label="vue 命名规范"><!---->vue 命名规范<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/vue%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html" aria-label="vue 使用总结"><!---->vue 使用总结<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" aria-label="/Vue/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html"><!---->/Vue/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Vue/keep-alive.html" aria-label="keep-alive 缓存"><!---->keep-alive 缓存<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/git.html" aria-label="git"><!---->git<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/package.json.html" aria-label="package.json"><!---->package.json<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%BB%9F%E4%B8%80%E6%8C%87%E5%8D%97.html" aria-label="代码风格统一指南"><!---->代码风格统一指南<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/babel.html" aria-label="/%E5%B7%A5%E7%A8%8B%E5%8C%96/babel.html"><!---->/%E5%B7%A5%E7%A8%8B%E5%8C%96/babel.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack.html" aria-label="webpack"><!---->webpack<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96.html" aria-label="模块化"><!---->模块化<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%B5%8B%E8%AF%95.html" aria-label="/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%B5%8B%E8%AF%95.html"><!---->/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%B5%8B%E8%AF%95.html<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.html" aria-label="/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.html"><!---->/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3.html" aria-label="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3.html"><!---->/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6.html" aria-label="/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6.html"><!---->/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84.html" aria-label="/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84.html"><!---->/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8.html" aria-label="链表"><!---->链表<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E6%A0%88.html" aria-label="/%E7%AE%97%E6%B3%95/%E6%A0%88.html"><!---->/%E7%AE%97%E6%B3%95/%E6%A0%88.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2.html" aria-label="/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2.html"><!---->/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97.html" aria-label="/%E7%AE%97%E6%B3%95/%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97.html"><!---->/%E7%AE%97%E6%B3%95/%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91.html" aria-label="二叉树"><!---->二叉树<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html" aria-label="动态规划"><!---->动态规划<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E7%B1%BB.html" aria-label="其他构造类"><!---->其他构造类<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85.html" aria-label="背包"><!---->背包<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8.html" aria-label="/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8.html"><!---->/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8.html<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BD%91%E7%BB%9C/HTTP.html" aria-label="HTTP"><!---->HTTP<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BD%91%E7%BB%9C/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.html" aria-label="/%E7%BD%91%E7%BB%9C/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.html"><!---->/%E7%BD%91%E7%BB%9C/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html" aria-label="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html"><!---->/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BD%91%E7%BB%9C/grpc.html" aria-label="grpc"><!---->grpc<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/web%E5%AE%89%E5%85%A8.html" aria-label="web 安全"><!---->web 安全<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/%E9%87%8D%E6%9E%84.html" aria-label="重构"><!---->重构<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93.html" aria-label="架构整洁之道"><!---->架构整洁之道<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/%E7%8A%B6%E6%80%81%E6%9C%BA.html" aria-label="状态机"><!---->状态机<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="设计模式"><!---->设计模式<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" aria-label="函数式编程"><!---->函数式编程<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/plantuml.html" aria-label="plantuml"><!---->plantuml<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E7%BC%96%E7%A8%8B/airbnb.html" aria-label="AirBNB"><!---->AirBNB<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/%E6%96%B0%E6%8A%80%E6%9C%AF/%E5%BE%AE%E5%89%8D%E7%AB%AF.html" aria-label="如何管理日益庞大的项目"><!---->如何管理日益庞大的项目<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E6%96%B0%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html" aria-label="/%E6%96%B0%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html"><!---->/%E6%96%B0%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/新技术/OAuth2.0与微信登陆.html" aria-label="/新技术/OAuth2.0与微信登陆.html"><!---->/新技术/OAuth2.0与微信登陆.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E6%96%B0%E6%8A%80%E6%9C%AF/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%8E%A2%E7%B4%A2%E5%92%8C%E6%BC%94%E8%BF%9B.html" aria-label="页面渲染探索和演进"><!---->页面渲染探索和演进<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/浏览器/README.html" aria-label="/浏览器/README.html"><!---->/浏览器/README.html<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84.html" aria-label="浏览器架构"><!---->浏览器架构<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/%E6%B5%8F%E8%A7%88%E5%99%A8/a-life-of-a-pixel%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93.html" aria-label="A life of a pixel"><!---->A life of a pixel<!----></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h1><h2 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域"><span>作用域</span></a></h2><ul><li>编译 <ul><li>分词/词法分析</li><li>解析/语法分析</li><li>代码生成</li></ul></li><li>演员表 <ul><li>引擎 <ul><li>负责整个 js 程序的编译和执行过程</li></ul></li><li>编译器 <ul><li>负责词法分析和代码生成等</li></ul></li><li>作用域 <ul><li>负责手机和维护所有声明的变量以及查询</li></ul></li></ul></li><li>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。赋值操作的左侧或右侧 <ul><li>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。</li></ul></li><li>作用域是根据名称查找变量的一套规则，当作用域隔离操作符号嵌套，例如函数嵌套时，就发生了作用域的嵌套，当我们在查找当前作用域的对应变量找不到时，引擎就会在外层嵌套的作用域继续找，直到找到为止。</li><li>词法作用域 <ul><li>定义在词法阶段的作用域</li><li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。</li><li>任何声明在某个作用域内的变量，都将附属于这个作用域。</li><li>函数声明提升</li></ul></li></ul><h2 id="执行环境" tabindex="-1"><a class="header-anchor" href="#执行环境"><span>执行环境</span></a></h2><p>执行环境定义了变量或者函数有权访问的其他数据</p><p>一个执行环境包含以下数据</p><p>变量对象、作用域链、this</p><h3 id="可执行代码" tabindex="-1"><a class="header-anchor" href="#可执行代码"><span>可执行代码</span></a></h3><p>全局代码、函数代码、eval 代码</p><h3 id="活动对象" tabindex="-1"><a class="header-anchor" href="#活动对象"><span>活动对象</span></a></h3><p>在函数上下文中，我们用活动对象来表示变量对象</p><p>只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p><h3 id="执行上下文的生命周期" tabindex="-1"><a class="header-anchor" href="#执行上下文的生命周期"><span>执行上下文的生命周期</span></a></h3><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段</p><p><strong>1.创建阶段</strong> 当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ol><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li><li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li><li>确定 this 指向</li><li>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</li></ol><p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h2><ol><li>闭包是指有权访问另一个函数内部变量的函数</li><li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</li><li>当在函数内部定义了其他函数时，就创建了闭包。</li></ol><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><ul><li>读取函数内部的变量,闭包可形成静态私有变量，即共享的局部私有变量</li><li>让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。封装对象的私有属性和私有方法</li></ul><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><ol><li>闭包内的 this 指向和匿名函数相同都是指向 window，要在外函数借用 this 才能正常获取</li><li>闭包内保存的变量不会被垃圾回收机制回收，会一直保存，滥用闭包会造成内存泄露</li></ol><h3 id="闭包在-chrome、引擎的应用" tabindex="-1"><a class="header-anchor" href="#闭包在-chrome、引擎的应用"><span>闭包在 chrome、引擎的应用</span></a></h3><ol><li>原始类型放在栈中，引用类型放在堆中，栈中因为要存放当前的执行上下文，空间较小，堆的空间较大</li><li>js 引擎会先编译，发现有引用外部变量，就会把这个变量放到堆中名为 closure 的变量当中，放到堆中就能够实现变量的保持，栈中的变量是在执行完后就销毁的</li></ol><h2 id="彻底搞懂-this" tabindex="-1"><a class="header-anchor" href="#彻底搞懂-this"><span><a href="https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.2.3" target="_blank" rel="noopener noreferrer">彻底搞懂 this</a></span></a></h2><p>用来指向当前代码运行时所处的上下文环境</p><h3 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么</span></a></h3><p>它指向当前代码运行时所处的上下文环境，也指向调用该函数的对象</p><ul><li><p>new 绑定</p><ul><li>const a = new A();</li></ul></li><li><p>显式绑定</p><ul><li>JavaScript 内置对象 Function 的三个原型方法 call()、apply()和 bind()，它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时让 this 指向这个对象</li><li>const b = A.bind(this);</li></ul></li><li><p>隐式绑定</p><ul><li>函数体内 this 的指向由调用位置的调用者决定。如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的 this 指向该对象。</li><li>对象属性引用链中只有最顶层或者说最后一层会影响调用位置,指向最终调用函数的对象</li><li>绑定丢失 <ul><li>虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是 func 函数本身，</li><li>因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,</li><li>因此函数体内的 this 指向 window，this.a 指向 window 的属性 a（全局变量 a）</li></ul></li></ul></li><li><p>默认绑定</p><ul><li>独立函数调用（无法应用后面其他指向规则时），在严格模式下绑定为 undefined，否则为 window 对象</li><li>定时器中的 this 为 window，不是函数本身</li></ul></li></ul><h3 id="进阶理解" tabindex="-1"><a class="header-anchor" href="#进阶理解"><span><a href="https://zh.javascript.info/reference-type" target="_blank" rel="noopener noreferrer">进阶理解</a></span></a></h3><ul><li><strong>为确保 <code>user.hi()</code> 调用正常运行，JavaScript 玩了个小把戏 —— 点 <code>&#39;.&#39;</code> 返回的不是一个函数，而是一个特殊的 <a href="https://tc39.github.io/ecma262/#sec-reference-specification-type" target="_blank" rel="noopener noreferrer">Reference Type</a> 的值。</strong></li><li>任何例如赋值 <code>hi = user.hi</code> 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉，而会取 <code>user.hi</code>（一个函数）的值并继续传递。所以任何后续操作都“丢失”了 <code>this</code>。</li><li>因此，<code>this</code> 的值仅在函数直接被通过点符号 <code>obj.method()</code> 或方括号 <code>obj[&#39;method&#39;]()</code> 语法（此处它们作用相同）调用时才被正确传递。还有很多种解决这个问题的方式，例如 <a href="https://zh.javascript.info/bind#solution-2-bind" target="_blank" rel="noopener noreferrer">func.bind()</a>。</li></ul><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h2><h3 id="命名函数表达式-nfe" tabindex="-1"><a class="header-anchor" href="#命名函数表达式-nfe"><span><a href="https://zh.javascript.info/function-object" target="_blank" rel="noopener noreferrer">命名函数表达式（NFE）</a></span></a></h3><p>Named Function Expression,指带有名字的函数表达式</p><ul><li>它(func)允许函数在内部引用自己。</li><li>它(func)在函数外是不可见的。</li><li>适用于函数递归，更加可靠的内部名称</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">let</span> <span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">who</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>who<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>who<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">&#39;Guest&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 现在一切正常</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> welcome <span class="token operator">=</span> sayHi<span class="token punctuation">;</span></span>
<span class="line">sayHi <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">welcome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, Guest（嵌套调用有效）</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="new-function-语法" tabindex="-1"><a class="header-anchor" href="#new-function-语法"><span><a href="https://zh.javascript.info/new-function" target="_blank" rel="noopener noreferrer">&quot;new Function&quot; 语法</a></span></a></h3><p>创建函数的语法：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">let</span> func <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token operator">...</span>argN<span class="token punctuation">]</span><span class="token punctuation">,</span> functionBody<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>使用 <code>new Function</code> 创建的函数，它的 <code>[[Environment]]</code> 指向全局词法环境，而不是函数所在的外部词法环境。因此，我们不能在 <code>new Function</code> 中直接使用外部变量。不过这样是好事，这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法</li><li>避免了与使用压缩程序而产生冲突的问题。 <ul><li>如果能访问外部变量，压缩后变量名称修改，会导致 Function 内的变量找不到，较为安全</li></ul></li><li>使用 new Function 代替 eval</li></ul><h3 id="惰性载入函数" tabindex="-1"><a class="header-anchor" href="#惰性载入函数"><span>惰性载入函数</span></a></h3><ul><li>函数重写</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token function-variable function">createHXR</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function-variable function">createXHR</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function-variable function">createXHR</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">&#39;Microsoft.XMLHTTP&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>声明时指定，利用闭包的特性，可以在函数内部改变外部变量的值，这样就可以实现惰性载入。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">const</span> createXHR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> xhr<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>xhr<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">&#39;Microsoft.XMLHTTP&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> xhr<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="箭头函数" tabindex="-1"><a class="header-anchor" href="#箭头函数"><span>箭头函数</span></a></h3><ul><li>箭头函数使用更加常见的词法作用域取消了传统的 this 机制</li><li>箭头函数常用于回调函数中，例如事件处理器或者定时器的回调函数 <ul><li>事件处理器的 this 指向事件的触发元素</li><li>定时器回调函数的 this 为 window 对象</li></ul></li><li>尽量避免使用 var self = this;否定 this 机制</li></ul><h3 id="轮询任务中-settimout-和-setinterval-以及-requestanimationframe-使用" tabindex="-1"><a class="header-anchor" href="#轮询任务中-settimout-和-setinterval-以及-requestanimationframe-使用"><span>轮询任务中 setTimout 和 setInterval 以及 requestAnimationFrame 使用</span></a></h3><ul><li>使用 <code>setInterval</code><ol><li>标准中，setInterval ()如果前一次代码没有执行完，则会跳过此次代码的执行。</li><li>浏览器中，setInterval()如果前一次代码没有执行完，不会跳过此次代码，而是将其插在队列中，等待前一次代码执行完后立即执行。</li><li>Node 中，setInterval()会严格按照间隔时间执行。</li><li><code>func</code> 函数的实际调用间隔要比代码中设定的时间间隔要短！</li></ol></li><li>使用嵌套的 <code>setTimeout</code><ul><li>就能确保延时的固定（这里是 100 毫秒）。这是因为下一次调用是在前一次调用完成时再调度的。</li></ul></li><li>使用 <code>requestAnimationFrame</code><ul><li>requestAnimationFrame 是一个比 setInterval 更高级的定时器，可以让我们更精确的控制时间间隔，并且可以控制帧率。</li><li>一般使用于 css 动画，因为它可以控制帧率，而 setInterval 只能控制时间间隔。 <ul><li>不卡的情况下，一般一秒内调用 60 次</li></ul></li></ul></li></ul><h3 id="立即执行函数" tabindex="-1"><a class="header-anchor" href="#立即执行函数"><span>立即执行函数</span></a></h3><p>一、是不必为函数命名，避免了污染全局变量</p><p>二、是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p><h4 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1"><span>作用</span></a></h4><p>这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>模块化开发，防止污染全局变量（避免使用全局变量）</li><li>可以访问函数内部变量并且让它一直保存在内存中</li></ul><h2 id="原型和原型链" tabindex="-1"><a class="header-anchor" href="#原型和原型链"><span><strong>原型和原型链</strong></span></a></h2><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对 象的原型。</p><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对 象的原型。</p><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><ul><li><p>prototype（原型对象）</p><ul><li>只有函数对象才有该属性</li><li>new 一个函数后生成的对象，会共享函数的 prototype 上的属性和方法，通过改构造函数产生的对象，可以继承该原型的属性和方法</li></ul></li><li><p>__proro__</p><ul><li><strong>proto</strong>属性指向当前对象的原型对象，即构造函数的 prototype 属性</li><li>对象或者函数对象都有该属性</li><li>原型链 <ul><li>原型也是对象，所以也会有原型，所以会形成原型链，一般原型链的末端是对象的原型为 null//Object.prototype.<em>proto</em>===null。空对象的原型为 null，还有 null 和 undefined 也没有原型。</li><li>在函数内部查找某个属性和方法时会沿着它的原型链查找，具体是查找它的<em>proto</em>指向的原型对象，默认是指向它的 prototype 即 obj.__proto.__=obj.prototype，如果<em>proto</em>指向被修改，它会去找这个被修改了的对象而不是它的 prototype，</li></ul></li></ul></li><li><p>constructor</p><ul><li>constructor 是显式原型 prototype 的一个属性 也就是说只能通过 obj.prototype.contructor 来访问,它指向原型的构造函数</li><li>如果用一个新对象覆盖函数的 prototype 属性值，新对象没有 constructor 属性，实例不能通过 constructor 指向正确的构造函数。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">person1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>获取实例对象 obj 的原型对象，有三种方法。</p><ul><li>obj.<strong>proto</strong><ul><li><strong>proto</strong>属性只有浏览器才需要部署，其他环境可以不部署</li></ul></li><li>obj.constructor.prototype <ul><li>在手动改变原型对象时，可能会失效</li></ul></li><li>Object.getPrototypeOf(obj) <ul><li>推荐使用</li></ul></li></ul></li><li><p>a.isPrototypeOf(b)//判断 a 是不是 b 的原型</p></li><li><p>如果用 delete 删除实例属性，就会沿用原型属性</p></li></ul><p>Object, Function, Array 等等这些都被称作是构造“函数”，他们都是函数。而所有的函数都是构造函数 Function 的实例。从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的 Function 构造函数的构造原型 Function.protorype 对象，所以：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token function">alert</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>与此同时，又因为 Function.prototype 是一个对象，所以他的构造函数是 Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的 Object 构造函数的构造原型 Object.prototype 对象，所以：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token function">alert</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>有趣的是根据我们通过原型链机制对 instanceof 进行的分析，我们不难得出一个结论：Function instanceof Function 依然返回 true, 原理是一样的</p><ol><li>Function 是构造函数，所以它是函数对象</li><li>函数对象都是由 Function 构造函数创建而来的，原型链机制解释为：函数对象的原型链中存在 Function.prototype</li><li>instanceof 查找原型链中的每一个节点，如果 Function.prototype 的构造函数 Function 的原型链中被查到，返回 true</li></ol><p>因此下面代码依然返回 true</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token function">alert</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// still true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="https://img2018.cnblogs.com/blog/1632878/201905/1632878-20190507094639999-1584111224.png" alt=""></p><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span><a href="https://www.cnblogs.com/Grace-zyy/p/8206002.html" target="_blank" rel="noopener noreferrer">继承</a></span></a></h2><p>要传实例的原因就是因为原型是对象，如果修改了子类的原型那么父类的原型也将随之更改，很危险</p><h3 id="原型链继承" tabindex="-1"><a class="header-anchor" href="#原型链继承"><span>原型链继承</span></a></h3><p>就是将父类的实例赋值给子类的原型（A.prototype=B=prototype 这样的话原型对象直接复制当然可以，但是我们这里要实现的是继承，子类如果和父类共用一个原型对象，那么子类就无法扩展自己的属性了）</p><p>缺点：1、新实例无法向父类构造函数传参。</p><p>2、继承单一（这点是因为直接将一个实例赋值给原型，而不能合并多个实例对象）</p><p>3、包含引用类型值的原型会被实例（子类）共享。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</p><h3 id="构造函数继承" tabindex="-1"><a class="header-anchor" href="#构造函数继承"><span>构造函数继承</span></a></h3><p>用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</p><p>缺点 ：方法都在构造函数内部不能函数复用。（应该意思就是没有原型链继承吧）</p><p>特点：</p><ol><li>解决了 superType 中的私有属性变公有的问题，可以传递参数</li><li>没有继承原型</li><li>解决原型链继承的缺点</li></ol><h3 id="组合继承" tabindex="-1"><a class="header-anchor" href="#组合继承"><span>组合继承</span></a></h3><p>组合原型链继承和借用构造函数继承）（常用）</p><p>特点：结合了两种模式的优点，传参和复用</p><p>缺点：调用了两次父类的构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p><h3 id="原型式继承" tabindex="-1"><a class="header-anchor" href="#原型式继承"><span>原型式继承</span></a></h3><p>用一个空函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。原型式继承本质其实就是个浅拷贝，以一个对象为模板复制出新的对象</p><p>特点：类似于复制一个对象，用函数来包装。借助一个空对象来是实现继承的好处是子类可以添加属于自己的方法而不会影响父类</p><p>缺点：</p><ol><li>所有实例都会继承原型上的属性。</li><li>无法实现复用。（新实例属性都是后面添加的）</li><li>无法实现多态，多继承</li></ol><h3 id="寄生式继承" tabindex="-1"><a class="header-anchor" href="#寄生式继承"><span>寄生式继承</span></a></h3><p>就是在原型式继承返回新对象之前在空对象上直接添加新方法，还是那个封装函数</p><h3 id="寄生组合继承" tabindex="-1"><a class="header-anchor" href="#寄生组合继承"><span>寄生组合继承</span></a></h3><p>寄生组合式继承与组合继承的区别就在于寄生的是通过将父类的原型链新对象赋值给子类，而组合继承是将父类的实例赋值给子类 原型链，这样通过实例的方式会将父类的属性也一并赋值给子类，而几声组合继承的父类属性为空，是新建的一个空对象</p><p>区别就在于有实例属性和实例属性为空，只是将原型对象赋值过去了</p><p>其实寄生组合继承相比较组合继承的有区别就是，坏的就在于父类自己的属性在子类的原型链上，比较混乱，而好的父类的属性在 F 中间对象上，这样就可以比较好的区分子类自己的属性和原型链上的属性。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">Target<span class="token punctuation">,</span> Origin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Origin</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span></span>
<span class="line">  <span class="token class-name">Target</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token class-name">Target</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Target<span class="token punctuation">;</span> <span class="token comment">//把Target的构造函数指向归位</span></span>
<span class="line">  <span class="token class-name">Target</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> <span class="token class-name">Origin</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">//为了让我们知道Target真正继承自谁</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 F 变为私有变量</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">var</span> inhert <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//闭包，变成私有化变量，在函数外部无法调用</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">Target<span class="token punctuation">,</span> Origin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Origin</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">Target</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">Target</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Target<span class="token punctuation">;</span> <span class="token comment">//把Target的构造函数指向归位</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">Target</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> <span class="token class-name">Origin</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">//为了让我们知道Target真正继承自谁</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>类数组</strong>：只要属性是非负整数，带有 length 属性的对象</p><h2 id="进制转换" tabindex="-1"><a class="header-anchor" href="#进制转换"><span>进制转换</span></a></h2><p>将十进制转为多进制，第二个参数指定要转换的进制</p><p>(56).toString(); //返回&quot;56&quot;</p><p>(5).toString(2);//返回字符串&quot;101&quot;</p><p>将多进制转为十进制，第二个参数是这个数本身的进制数</p><p>如果基数是 0 返回十进制，如果是不能正确返回的 parseInt(&#39;141&#39;,3)，141 超出的 3 进制，返回 1</p><ul><li>如果字符串 string 以&quot;0x&quot;或者&quot;0X&quot;开头, 则基数是 16 (16 进制).</li><li>如果字符串 string 以&quot;0&quot;开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，<strong>永远都要明确给出 radix 参数的值</strong>。</li><li>如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。</li></ul><p><strong>parseInt</strong>(101,2)//返回 5 parseInt(8,3)//返回 NaN parseInt(16,3)//返回 1 parseInt(&#39;dsff66&#39;,16)//返回 13</p><p>如何利用位操作判断一个整数是不是 2 的整数次方</p><p>这道题其实思路很多，但是比较简单的方法我感觉是<strong>先把这个数转化为二进制，如果是 2 的整数次方，那么第一位是 1，其余都是 0</strong>。如果满足了这个，那么这个数就是 2 的整数次方</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">2^4=16</span>
<span class="line"></span>
<span class="line">2^5=32</span>
<span class="line"></span>
<span class="line">2^6=64</span>
<span class="line"></span>
<span class="line">2^7=128</span>
<span class="line"></span>
<span class="line">2^8=256</span>
<span class="line"></span>
<span class="line">2^9=512</span>
<span class="line"></span>
<span class="line">2^10=1024</span>
<span class="line"></span>
<span class="line">2^11=2048</span>
<span class="line"></span>
<span class="line">2^12=4096</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="堆栈的区别" tabindex="-1"><a class="header-anchor" href="#堆栈的区别"><span>堆栈的区别</span></a></h2><ul><li>堆栈空间分配区别： <ul><li>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</li><li>堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。</li></ul></li><li>堆栈缓存方式区别： <ul><li>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</li><li>堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</li></ul></li><li>堆栈数据结构区别： <ul><li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li><li>栈（数据结构）：一种先进后出的数据结构。</li></ul></li></ul><p>还有一个问题是否所有的基本类型都储存在栈中呢？</p><p>并不是，当一个基本类型被闭包引用之后，就可以长期存在于内存中，这个时候即使他是基本类型，也是会被存放在堆中的。</p><ul><li><a href="https://www.cxymsg.com/guide/memory.html#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6" target="_blank" rel="noopener noreferrer">https://www.cxymsg.com/guide/memory.html#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6</a></li><li>https://www.jianshu.com/p/b8ed21e8a4fb</li></ul><hr><h3 id="垃圾回收和定时器回调" tabindex="-1"><a class="header-anchor" href="#垃圾回收和定时器回调"><span>垃圾回收和定时器回调</span></a></h3><p>当一个函数传入 <code>setInterval/setTimeout</code> 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token comment">// 在调度程序调用这个函数之前，这个函数将一直存在于内存中</span></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>setInterval</code>，传入的函数也是一直存在于内存中，直到 <code>clearInterval</code> 被调用。</p><p>如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>setInterVal 是精准的时间间隔</li><li>setTimeout 是每次在回调执行完后再调度的</li><li>定时器的函数会一直保持在内存不释放外部引用的闭包变量，尽量用 clear 取消掉可以取消函数的内存占用</li><li>一般认为的最佳方案是：<strong>用 setTimeout 模拟 setInterval，或者特殊场合直接用 requestAnimationFrame</strong></li><li>JS 高程中有提到，JS 引擎会对 setInterval 进行优化，如果当前事件队列中有 setInterval 的回调，不会重复添加。不过，仍然是有很多问题</li></ul><h2 id="array-sort-的理解" tabindex="-1"><a class="header-anchor" href="#array-sort-的理解"><span>Array.sort()的理解</span></a></h2><p>原题目：</p><ul><li>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</li></ul><p>我的答案：</p><ul><li>[102, 15, 22, 29, 3, 8]</li></ul><p>解析：</p><p>根据 MDN 上对 Array.sort()的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以&#39;102&#39; 会排在 &#39;15&#39; 前面。以下是 MDN 中的解释原文：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">返回值大于0 即a-b &gt; 0 ， a 和 b 交换位置</span>
<span class="line">返回值大于0 即a-b &lt; 0 ， a 和 b 位置不变</span>
<span class="line">返回值等于0 即a-b = 0 ， a 和 b 位置不变</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="slice-substring-substr-的区别" tabindex="-1"><a class="header-anchor" href="#slice-substring-substr-的区别"><span><a href="https://blog.csdn.net/qq_44352182/article/details/89889778" target="_blank" rel="noopener noreferrer">slice\substring\substr 的区别</a></span></a></h2><p>substr 和 substring 都只是 string 的方法，slice 都可，splice 只能操作数组</p><ul><li>substring，若 start&gt;stop，则会交换两者，若任一方为负数，则先变为 0</li><li>substr(start,length),如果 start 为负数，那么 start=str.length+start，如果 length 为负数或者 0，那么返回空字符串</li><li>slice，如果 start 或者 stop 为负数，那么负数的选项从数组尾部开始算起的位置，最后一个数字为-1，</li></ul><h3 id="区别数组的方法" tabindex="-1"><a class="header-anchor" href="#区别数组的方法"><span>区别数组的方法</span></a></h3><ul><li>constructor alert(arr.constructor === Array); // true</li><li>object.prototype.toString.call</li><li>instanceOf 例如 alert(arr instanceof Array); // true</li><li>Array.isArray()</li></ul><p>instanceOf 缺陷，因为 instanceOf 是沿着原型链查找，所以[] instanceOf Object//true</p><p>function new(func){ const a = {};</p><p>return a; }</p><p>const a = new Function();</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link label" href="https://github.com/liujia6/liujia6.github.io/edit/main/JS/基础.md" aria-label="帮助我们改善此页面！" rel="noopener noreferrer" target="_blank"><!--[--><svg class="edit-icon" viewbox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->帮助我们改善此页面！<!----></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: liujia11@qianxin.com">liujia6</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><!----><a class="route-link auto-link next" href="/JS/%E5%BC%82%E6%AD%A5.html" aria-label="异步"><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>异步</span></div></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-BYS36vur.js" defer></script>
  </body>
</html>
