## [浏览器对输入事件的处理](https://my.oschina.net/u/4594011/blog/4677018)

当页面渲染完毕以后，TAB内已经显示出了可交互的WEB页面，用户可以进行移动鼠标、点击页面等操作了，而当这些事件发生时候，浏览器是如何处理这些事件的呢？

以点击事件（click event）为例，让鼠标点击页面时候，首先接受到事件信息的是`Browser Process`，但是Browser Process只知道事件发生的类型和发生的位置，具体怎么对这个点击事件进行处理，还是由Tab内的`Renderer Process`进行的。Browser Process接受到事件后，随后便把事件的信息传递给了渲染进程，渲染进程会找到根据事件发生的坐标，找到目标对象（target），并且运行这个目标对象的点击事件绑定的监听函数（listener）。

1. 用户`滚动页面`，`触碰屏幕`以及`移动鼠标`等操作都可以看作来自于用户的输入事件。
2. **浏览器进程**（browser process）第一个接收到该事件，包含了一些该事件发生的信息
3. 浏览器进程会将事件的类型（如`touchstart`）以及坐标（coordinates）发送给**渲染进程**
4. 渲染进程会找到事件的目标对象（target）然后运行这个事件绑定的监听函数（listener）
5. 如果该元素没有绑定监听事件，直接由**合成线程**处理
6. 当合成线程向主线程发送输入事件时，主线程要做的第一件事是通过命中测试**（hit test）**去找到事件的目标对象（target）。具体的命中测试流程是遍历在渲染流水线中生成的绘画记录（paint records）来找到输入事件出现的x, y坐标上面描绘的对象是哪个。

### 浏览器事件处理优化

在上面的文章中我们有说过显示器的刷新频率通常是一秒钟60次以及我们可以通过让JavaScript代码的执行频率和屏幕刷新频率保持一致来实现页面的平滑动画效果（smooth animation）。对于用户输入来说，触摸屏一般一秒钟会触发60到120次点击事件，而鼠标一般则会每秒触发100次事件，因此输入事件的触发频率其实远远高于我们屏幕的刷新频率。

如果每秒将诸如`touchmove`这种连续被触发的事件发送到主线程120次，因为屏幕的刷新速度相对来说比较慢，它可能会触发过量的点击测试以及JavaScript代码的执行。

为了最大程度地减少对主线程的过多调用，Chrome会合并连续事件（例如`wheel`，`mousewheel`，`mousemove`，`pointermove`，`touchmove`），并将调度延迟到下一个`requestAnimationFrame`之前。

和之前相同的事件轴，可是这次事件被合并并延迟调度了

任何诸如`keydown`，`keyup`，`mouseup`，`mousedown`，`touchstart`和`touchend`等相对不怎么频繁发生的事件都会被立即派送给主线程。

- **非快速滚动区域 - non-fast scrollable region**：合成线程会将页面那些注册了事件监听器的区域标记为“非快速滚动区域”（Non-fast Scrollable Region）

- 意味着即使你页面的某些区域压根就不在乎是不是有用户输入，当用户输入事件发生时，合成线程每次都会告知主线程并且会等待主线程处理完它才干活。因此这种情况下合成线程就丧失提供流畅用户体验的能力了（smooth scrolling ability）。

- 为了减轻这种情况的发生，您可以为事件监听器传递`passive：true`选项。 这个选项会告诉浏览器您仍要在主线程中侦听事件，可是合成线程也可以继续合成新的帧。

- ```javascript
  document.body.addEventListener('touchstart', event => {
      if (event.target === area) {
          event.preventDefault()
      }
   }, {passive: true});
  ```

- 根据规范，`passive` 选项的默认值始终为false。但是，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。

- 添加passive参数后，`touchmove`事件不会阻塞页面的滚动（同样适用于鼠标的滚轮事件）

- 事件处理程序不会调用 preventDefault 来阻止默认滑动行为。

  总结：浏览器的dom的默认事件由合成器线程处理，如果绑定了事件监听函数，那么会合成器线程会先交给主线程处理，并等待其处理完成，再由自己处理默认事件。如果页面调用了preventDefault,合成器线程也是在其调用的时候才知道，会浪费合成器的等待时间