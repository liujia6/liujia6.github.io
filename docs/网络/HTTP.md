# HTTP

## 定义

- 超文本是指不同的文本之间可以通过超链接来连接起来，从而形成一个网络。
- HTML，全称超文本标记语言（Hyper Text Markup Language），是超文本的一种实现方式。它使用一系列标签来标记网页中的文本、图片、音频、视频等内容。还创建了网页中的超链接，使得用户可以在不同的信息节点之间自由跳转。
- HTTP，全称超文本传输协议（Hypertext Transfer Protocol），是一种应用层协议，用于在计算机网络中传输超文本。HTTP 协议是客户端（通常是浏览器）和服务器之间请求和应答的标准，是互联网上应用最为广泛的一种网络协议。

## HTTP/0.9

- 只支持 get 请求，响应为 html 文档格式的字符串

## HTTP/1.0

- 支持 get、post、head
- 包含基本的头信息、状态码等
- 支持各种数据类型

头信息必须是 ASCII 码，后面的数据可以是任何格式

**缺点：**

1. 一个请求发送一个请求，之后连接就关闭。
2. connection：keep-alive 的设置不是标准字段，不同浏览器的实现不一致

## HTTP/1.1

- tcp 连接默认不关闭
  - 可以被多个请求复用，不用声明 connection：keep-alive，
  - 客户端发现对方一段时间没有活动自动关闭 connection：close。规范的做法是在最后一个请求发送 connection：close
  - 同一个域名，一般允许同时建立**6**个持久连接
- 管道机制
  - 在一个 tcp 连接里，客户端可以同时发送多个请求，不用等前面的收到回应再发送
  - content-length 字段声明本次回应的数据长度，区分数据包
- 分块传输编码

  - transfer-encoding：chunked 表示回应将由数量未定的数据块组成，取代 content-length
  - 数据之前，16 进制数值表示块长度，最后大小为 0 的块表明本次传输完成

- 新的方法例如 put、patch、head、options、delete
- host 头域：将请求发往同一台服务器上的不同网站

**缺点**

- 一个 tcp 连接的通信的服务器回应是按照次序进行的，要是有一个回应特别慢，会发生队头阻塞。

## HTTP/2:基于 SPDY 协议

- **二进制协议**： HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制。
  - 二进制数据可以直接由计算机硬件处理，而无需像文本格式那样进行复杂的解析，提高解析效率
  - 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
- **多路复用**
  - **帧**（Frames）：最小的通信单位：这些帧可以是不同类型的，如 HEADERS、DATA、PUSH_PROMISE 等，并且它们可以在单个 TCP 连接上交错发送，**无需等待**其他帧的完成。
  - **流**（Streams）：HTTP/2 通过流来管理这些帧的发送和接收。每个请求或响应都对应一个流，并且每个流都有一个唯一的标识符。多个请求和响应可以在同一个 TCP 连接上交错发送，而不会相互干扰。从而实现**多路复用**。这意味着即使某个请求因为某种原因被延迟，其他请求也可以继续发送和接收数据，从而大大提高了性能
    - 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。
  - **优先级**（Priorities）：HTTP/2 允许客户端为每个流设置优先级。当网络拥塞或服务器资源有限时，服务器可以根据这些优先级来决定先处理哪些流。这有助于确保重要的请求得到优先处理。
- 服务端推送
  - 可以提升首屏加载速度，它允许 Web 服务器在收到浏览器的请求之前提前发送一些资源给客户端
- 头部压缩
  - 通过 HPACK 算法有效减少了头部字段的传输大小，提高了网络传输的性能和效率
    - 在客户端和服务器两端建立“字典”，用索引号表示重复的字符串。对于相同的数据，不再通过每次请求和响应发送，而是使用首部表中的引用。这种机制可以大大减少冗余数据的传输，降低开销。
    - 采用哈夫曼编码来压缩整数和字符串，从而达到高压缩率（50%~90%）

参考：

- [HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)
- [理解 HTTP 协议](https://www.cnblogs.com/wxisme/p/6212797.html)
- [深入理解 http2.0 协议，看这篇就够了！ - 知乎](https://zhuanlan.zhihu.com/p/89471776)

## [图解 HTTP 总结](https://segmentfault.com/a/1190000014572024)
- [传输编码与内容编码](https://blog.csdn.net/swt369/article/details/77847896)
- 20x
  - 206 partial-content
- 30x重定向
  - 301\302\303在标准上都是不允许将请求方法修改的
  - 然而大多数浏览器在实现上都将301\302\303改为了GET
  - 307用于表示不允许修改原有请求方式的临时重定向


## [HTTPS](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#https-%E5%8D%8F%E8%AE%AE)

HTTPS 指的是超文本传输安全协议，基于 HTTP 协议之上，新增了 TLS/SSL 来对数据加密。

使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立 刻发现。它还配备了身份证书，防止身份被冒充的情况出现。

### HTTP 存在的问题

1. HTTP 报文使用明文方式发送，可能被第三方窃听。
1. HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。
1. HTTP 还存在认证的问题，第三方可以冒充他人参与通信。

### 区别

- HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高

### 原理

- 对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

- 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

- 因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。

- 但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

- 为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。

### 握手过程说明

- 利用了证书的**数字签名**（私钥加密，公钥解密）进行了身份验证，以及**数字摘要**（常见例如哈希算法）进行完整性校验
- 使用证书的**非对称加密**（公钥加密、私钥解密），安全的协商出对话秘钥的算法
- 使用这个协商出来的对话秘钥利用**对称加密**来加密后续的通话。

对话秘钥的协商内容

- 3 个随机数
  - **Client Random 和 Server Random**：
    - 这两个随机数由客户端和服务器在握手阶段第一步和第二步分别生成并交换。它们被用于生成最终的对称加密密钥，确保每次会话的密钥都是唯一的，从而增加了通信的安全性。
    - 使用两个随机数而不是一个，可以进一步增加密钥的复杂性和不可预测性，使得攻击者更难通过猜测或暴力破解的方式来获取密钥。
  - **Pre-Master Secret**：
    - 这个随机数由客户端生成，并使用服务器的公钥进行加密后发送给服务器。服务器使用其私钥解密后得到这个随机数。
    - Pre-Master Secret 的引入是为了在非对称加密和对称加密之间建立一个安全的桥梁。通过它，客户端和服务器可以安全地协商出一个对称加密密钥，该密钥将用于后续的加密通信。
    - 使用 Pre-Master Secret 作为第三个随机数，进一步增强了密钥生成的复杂性和安全性。即使攻击者能够截获 Client Random 和 Server Random，没有 Pre-Master Secret，他们也无法生成正确的对称加密密钥。
- 加密算法
  - 客户端和服务使用各自都支持的同样的加密算法，加上 3 个随机数得到对话秘钥的生成方式

### TLS 握手过程

1. 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
4. 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
5. 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。

参考

- [Front-End-Interview-Notebook/计算机网络/计算机网络.md at master · CavsZhouyou/Front-End-Interview-Notebook](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#https-%E5%8D%8F%E8%AE%AE)
- [面试官：为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？ | web 前端面试 - 面试官系列](https://vue3js.cn/interview/http/HTTPS.html#%E4%B8%80%E3%80%81%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7)
- [详解 HTTP2.0 及 HTTPS 协议 - 掘金](https://juejin.cn/post/7034668672262242318)

## DNS 查询过程

域名缓存

1. 浏览器缓存
2. 操作系统缓存，hosts 文件

查询方式

1. 递归查询，用户只需要查询根域名网站，根域名网站没有的话自己查到了再给我
2. 迭代查询，用户去根域名服务器查找不到，根域名告诉你去哪里查，自己一层层去各个服务器查，直到找到为止。

查询过程

- 本地
  - 浏览器域名缓存
  - 操作系统域名缓存
  - 本地域名服务器
- 网络查询
  - 根域名服务器
  - 顶级域名服务器
  - 权限域名服务器
- 获取得到后分别存储到本地的缓存当中

## CDN

通过缓存代理和负载均衡服务器，加速了网站静态内容的访问速度以及访问压力，避免了一台服务器被攻击整个服务崩溃的问题

DNS 查询->cname 的 CDN 专用服务器->负载均衡服务器->就近的缓存服务器（没找到内容回源站查找）

1. 服务器查询 DNS 域名
2. DNS 解析权会交给域名对应的的 CNAME 服务器（CDN 专用 DNS 解析服务器）
3. CNAME 服务器会返回用户 CDN 的全局负载均衡设备 IP 地址并发起请求
4. CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的缓存服务器地址
5. 如果服务器中没有内容的话，会回溯到源站请求内容

## 强缓存

[HTTP 协议 | 前端面试与进阶指南](https://front-end-interview-shenfeng1945.netlify.app/guide/http.html#http%E7%9A%84%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F)

- 强缓存指定过期时间
  - Expires：过期时间
  - cache-control：max-age=3600，该值优先
  - 场景
    - 用于部分明确什么时候更新的数据
    - 对于不会再更新的数据，或者实时性要求不强的数据，可以设置一个超长的时间，http1.1 规定不能超过 1 年以上
- vary 首部，指定缓存单位
  - vary 用于指定除 URI 外使用哪个请求首部来确定唯一的数据，内容协商
