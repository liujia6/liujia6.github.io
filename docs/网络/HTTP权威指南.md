## HTTP权威指南

- 超文本传输

### 字符编码：ASCII，Unicode 和 UTF-8

- 二进制是起源，一个0或1就是1位
- 8个二进制位称为一个字节，拥有256种状态
- ASCII编码拥有128个字符的编码，是英语字符与二进制位之间的关系映射。但是第一位始终为0不使用，只占用7位，一个字节就是一个英语字符
- 非ASCII编码，英语用128个符号编码够了，但是其他语言不够，中文由于一个字节只有256中，不够，所以采用两个字节，简体中文常见的编码方式是 GB2312
- Unicode将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码
- Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储
- UTF-8 是 Unicode 的实现方式之一
- UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度
  - 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
  - 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
- utf-8的优点在于一个英文只要一个字节，但是一个中文却是3个字节，utf-16的优点在于编码长度固定，一个中文只要两2个字节，但是一个英文也要两个字节。所以对于英文网页utf-8编码更加有利，而对于中文网页使用utf-16应该更加有利
- Java和JS的字符串都是使用UTF-16编码，因为它有长度比较固定的优势，不像UTF-8字节数可能从1变到4。如下图所示：英文和中文长度都是1，而Emoj的长度是2，因为长度单位是2个字节作为1，Emoj的需要4个字节，因此长度是2
- charCodeAt返回当前字符的utf编码
- 如果是要检测中文的话可以使用正则表达式，看当前符号是否落在中文编码的范围内：
- utf是国际标准，规定了每个字符的编码，而utf-8/utf-16决定了utf该如何存储与读取，utf-8的优点是对于英文比较有利，比较节省空间，utf-16对于中文比较有利。但是如果西方国家使用utf-8，然后东方国家使用utf-16，那么互联网可能就乱了，所以从统一标准的角度我们还是使用utf-8。还讨论了GBK编码和乱码的问题，如果一个字符存的时候是用的一种编码，但是读的时候却用的另一种编码，那就会对不上原先的字符，就会出现乱码的情况。另外，由于utf-16编码长度比较固定，所以JS和Java使用了utf-16做为它们在内存里字符串的编码。根据实验，meta的charset标签在没有设置响应头的charset时可以起作用。
- [全角与半角](https://jingyan.baidu.com/article/47a29f24671346c0142399fe.html)
  - 全角的标点符号占2个字节，半角的标点符号占1个字节
  - 半角是ASCII的编码，全角是GB2312的编码


```
Unicode符号范围     |        UTF-8编码方式
(十六进制)        |              （二进制）
----------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

## [url编码](http://www.ruanyifeng.com/blog/2010/02/url_encoding.html)

- 一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号
- 只有字母和数字[0-9a-zA-Z]、一些特殊符号"$-_.+!*'(),"[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。
- 网址路径的编码，用的是utf-8编码
- 查询字符串的编码，用的是操作系统的默认编码
- 网页里的form编码其实不完全取决于网页编码，form标记中有一个accept-charset属性，在非ie浏览器种，如果将其赋值(比如accept-charset="UTF-8")，则表单会按照这个值表示的编码方式进行提交。
- 在已打开的网页上，直接用Get或Post方法发出HTTP请求,编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定。
- 在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码\<meta http-equiv="Content-Type" content="text/html;charset=xxxx">

由于不同的方式的编码不同，所以我们在传送数据之前用js处理编码的方法来统一处理。

全角：LOVE
半角：ＬＯＶＥ

### 编码方式

| 编码方式                              | 作用对象    | 具体编码机制                                                 |
| ------------------------------------- | ----------- | ------------------------------------------------------------ |
| escape/unescape                       | 字符串      | Unicode编码值                                                |
| encodeURI/decodeURI                   | 整个URL     | 除了常见的符号以外，对其他一些在网址中有特殊含义的符号"; / ? : @ & = + $ , #"，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上% |
| encodeURIComponent/decodeURIComponent | URL中的参数 | "; / ? : @ & = + $ , #"，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码,具体的编码方法，与encodeURI一致 |

如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。

## [base64](https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%e5%9b%be%e7%89%87-%e9%a1%b5%e9%9d%a2%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96/)

> thunder://QUFodHRwOi8vd3d3LmJhaWR1LmNvbS9pbWcvc3NsbTFfbG9nby5naWZaWg==

- 一堆连续字母，最后有1~2个"="的代码就是base64
- 将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右

##### base64:URL传输图片文件的好处在于：

- 减少了HTTP请求
- 某些文件可以避免跨域的问题
- 没有图片更新要重新上传，还要清理缓存的问题

##### 什么情况下用base64：

- 不能与其他图片以CSS Sprite的形式存在，只能独行
- 基本上很少被更新
- 实际尺寸很小
- 在网站中大规模使用

HTML5 中atob 和 btoa 方法支持 Base64 编码和解码。

- b代表base64，a表示ascii码

```javascript
var a = "https://lin-xin.github.io";
var b = btoa(a);
var c = atob(b);

console.log(a);     // https://lin-xin.github.io
console.log(b);     // aHR0cHM6Ly9saW4teGluLmdpdGh1Yi5pbw==
console.log(c);     // https://lin-xin.github.io复制代码btoa

```

- 参数中带中文，已经超出了8位ASCII编码的字符范围，浏览器就会报错。所以需要先对中文进行encodeURIComponent 编码处理。

```
var a = "哈喽 世界";
var b = btoa(encodeURIComponent(a));
var c = decodeURIComponent(atob(b));

console.log(b);     // JUU1JTkzJTg4JUU1JTk2JUJEJTIwJUU0JUI4JTk2JUU3JTk1JThD
console.log(c);     // 哈喽 世界
```


## 服务器的概念

- 分两种
  - 硬件主机
  - 24小时服务的软件程序，可以用node的server模块穿件一个clientServer并监听端口，就可以对外提供服务来了 
- 内容分为 
  - 静态文件服务器
  - 动态文件服务器



## 代理

### 定义

- 代理是位于客户端与服务端之间的HTTP实体
- 它既是web服务器又是客户端
- 代理的url包括主机名，普通没有
  ![image](https://note.youdao.com/yws/public/resource/c9f1b9f836ce443c9e328d9da17c3c84/xmlnote/5BB0842ECFE84C86948C30F835C5847A/13606)

### 应用

我的理解，就和中间件一样可以对请求和响应根据需求做出处理比如

- 网站访问控制：儿童过滤器，公司、在入口部署
- 安全防火墙
- 反向代理（在服务器之前代替服务器，称为替代物，会假扮服务器的ip端口）

### 代理如何获取流量

1. 通过在浏览器设置代理，称为正向代理
   - 浏览器设置代理、chrome用一个扩展程序
   - [pac文件](https://www.barretlee.com/blog/2016/08/25/pac-file/)
2. 在网络基础设备中导入代理，称为拦截代理
3. 修改dns，添加代理
4. 服务器设置重定向，称为反向代理

## 网关

- 对比代理，网关可以处理不同协议间如http/ftp的对话，代理只处理http请求,但实际上两者区别也比较模糊，因为代理也要处理不同版本间的http，商业化的代理也会支持ssl、ftp
- 无论是 Apache 还是 Nginx，首先它们是 HTTP 服务器，其次实现代理和反向代理只是它们的一个功能而不是全部



### [TCP编程](https://www.liaoxuefeng.com/wiki/897692888725344/923056653167136)

Socket是一套完整的TCP,UDP协议的接口。
你浏览的网页（网址以http开头)都是http协议传输到你的浏览器的, 而http是基于Socket之上的。
socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开
Socket是一个针对TCP和UDP编程的接口，可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层 ，而http是个应用层的协议，它实际上也建立在TCP协议之上。(HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。)

Socket定义： 就是利用模式"打开open->write/read->关闭close"来实现的，socket是一种特殊的文件。

HTTP协议：简单对象访问协议，对应于应用层 ，HTTP协议是基于TCP连接的

TCP协议： 对应于传输层

IP协议： 对应于网络层

TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。

Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议

http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉;
socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开

Socket是一个针对TCP和UDP编程的接口，可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层 ，而http是个应用层的协议，它实际上也建立在TCP协议之上。(HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。)
Socket定义： 就是利用模式"打开open->write/read->关闭close"来实现的，socket是一种特殊的文件。

Socket的网络连接步骤
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

## 重定向与负载均衡

原因

1. 可靠，保证一个出错，还有其他的顶替
2. 更快返回响应
3. 减少网络拥塞

- 通用重定向

  1. HTTP重定向301
     - 缺点：时延增加，增加服务器的负担，处理不了故障
  2. DNS重定向
     - dns轮转
     - 不会平衡单个客户端的负载
     - 负载均衡算法
     - 邻接路由算法
     - 故障屏蔽算法
  3. MAC转发
     - 在交换机上编写程序，将对应MAC地址流量，转发到代理缓存上，通常将骑牛转发给几个代理缓存，并在其中平衡负载或者备用HTTP服务器，
     - 注意MAC转发是点对点的，只能一跳远
  4. IP地址转发
     - IP地址转发通MAC转发类似，更加自由，没有一跳远的限制，只需要位于交换机的上游，称为NAT，网络地址转换
     - 对称路由的限制，来去的路线必须一致
     - 完全NAT：源IP地址为交换机的IP，缺点：无法确认唯一客户端，无法实现付费
     - 半NAT：源IP不变，缺点：需要确保实现对称路由
  5. 网元控制协议NECP
     - 网元是指路由器、交换机等设备网络元素
     - 服务器元素SE是指web服务器和代理缓存等提供请求设备

- 代理重定向

  - 显式浏览器配置
  - 代理自动配置PAC协议，
    - 让浏览器获取PAC文件，说明了每个URL关联的代理，为PAC文件关联一个特定的服务器
  - WPAD代理自动发现协议
    - 不要求用户手工配置dialing设置，不依赖流量拦截，为web浏览器提供一种发现并使用附近代理的范式    

- 缓存重定向：因为需要分配到可能包含特定内容的位置，要求可靠、高效且能感知内容

  1. **WCCP重定向**，使路由器将web流量重定向到代理缓存中，负责路由器和缓存服务器之间的通信，这样路由器就可以对缓存验证，在缓存中负载均衡，并将特定类型的流量发送给特定的缓存
     - GRE分组封装：支持WCCP的路由器用服务器IP地址将HTTP分组封装起来，将其重定向到特定的服务器上。
     - 服务组：由一组支持WCCP的路由器和缓存组成，可以交换WCCP报文

  - **ICP因特网缓存协议**：允许缓存在兄弟缓存中查找命中的内容，会同时询问附近的多个缓存，看是否有特定URL，返回HIT或MISS，以一层为单位查询，打开HTTP连接传输
  - **CARP缓存阵列路由协议**：使用多个代理服务器将负载分散到一组服务器上，是ICP的替代品，可以通过单次查找确定对应缓存服务器的位置
  - **HTCP超文本缓存协议**：允许兄弟缓存之间通过URL和所有的骑牛以及响应首部来相互查询文档是否存在，而且允许对方修改资源


## 国际化编码

- 客户端的Accept-Charset、Accept-Language
- 服务端的Content-type中的charset和content-Language首部
- 字符集：把字符转换为二进制码的编码算法
- 字符集标记由IANA的MIME字符集注册机构标准化

### 内容和传输编码

1. content-length是压缩后或包含内容编码后的大小
2. 除非使用分块编码，否则是必须的报文实体字段
3. content-length的作用
   1. 检测出服务器崩溃导致的**报文截尾**
      - 早期是用正确关闭连接的方法划定报文结束 ，但是如果没有content-length无法判别服务器崩溃异常导致的连接关闭
      - 若有缓存代理服务器，若有错误没有识别，会存储不完成的内容并重复使用，缓存服务器不会处理没有content-length的报文
      - HTTP1.1规定若检测到无效长度需要通知用户
   2. 对共享**持久连接**的多个报文正确分段
      - content-length首部对持久连接必不可少，因为持久连接，无法通过连接关闭判断报文结束
      - 如果采用分块编码可以没有content-length首部
4. 内容编码：发送前进行编码，与内容的具体格式细节紧密相关，gzip压缩文本，jpeg不能用gzip
   - 压缩
   - 搅乱或加密
   - Content-Encoding：用于指定报文主体已经采用的编码方式，属于端到端首部，即在整个传输过程中有效。
   - Accept-Encoding：用于告知服务器客户端能够处理的编码方式和相对优先级，属于端到端首部，即**在整个传输过程**中有效。
5. [传输编码和分块编码](https://www.geek-share.com/detail/2715577569.html)
   - HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接
   - 可以通过传输编码把报文扰乱保证安全，不过有了SSL就不太考虑用此了
   - Transfer-Encoding：用于指定传输报文主体时使用的编码方式，属于逐跳首部，即只在两个**节点间**有效。
   - TE：用于告知服务器客户端能够处理的编码方式和相对优先级，属于逐跳首部，即只在两个节点间有效。

**Vary首部：**定义了服务器由什么的不同而发送不同的实体内容

- 若所提供的文档取决于User-Agent首部，vary首部就必须包含User-Agent

- 所服务器Vary：User-Agent，cookie，大量不同的User-Agent，cookie会产生非常多的变体，缓存必须为每个变体保存相应文档版本

- Vary: User-Agent

  ​	例如你提供给移动端的内容是不同的，可用防止你客户端误使用了用于桌面端的缓存。 并可帮助Google和其他搜索引擎来发现你的移动端版本的页面，同时告知他们不需要Cloaking。




[从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://static.kancloud.cn/xiaoyulive/system/598702)