# 设计模式

设计模式的世界丰富多彩，比如生产一个个“产品”的工厂模式，衔接两个不相关接口的适配器模式，用不同的方式做同一件事的策略模式，构建步骤稳定、根据构建过程的不同配置构建出不同对象的建造者模式等等。

无论何种设计模式，都是基于六大设计原则：

- 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。
- 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。
- 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。
- 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
- 迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。
- 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

## AOP面向切面编程

```javascript
export default {
  around (obj, fn, beforeFn) {
    let _fn = obj[ fn ]
    obj[ fn ] = function () {
      _fn.call(this)
      let ret = beforeFn.call(this)
      _fn.call(this, ret)
    }
  },
  before (obj, fn, beforeFn) {
    let _fn = obj[ fn ]
    obj[ fn ] = function () {
      let ret = beforeFn.apply(this, arguments)
      return _fn.call(this, ret)
    }
  },
  after (obj, fn, beforeFn) {
    let _fn = obj[ fn ]
    obj[ fn ] = function () {
      let ret = _fn.apply(this, arguments)
      return beforeFn.call(this, ret)
    }
  }
}

```



单例模式

**工厂模式：** 工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。

**发布订阅模式**

**装饰模式：** 装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。例如window.onload。ES7 中的装饰器语法

**适配器模式** 适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。

**外观模式：** 外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。例如addevent函数

**代理模式** : 事件代理就用到了代理模式，还有proxy

**状态模式**

### 单例模式

单例模式的定义是：（保证一个类仅有一个实例），并提供一个访问它的全局访问点。

单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏

览器中的 window 对象等。在 JavaScript开发中，单例模式的用途同样非常广泛。试想一下，当我

们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少

次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。

实现；是用一个变量来标志当前是否已经为某个类创建

过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象

### 策略模式

策略模式的定义是：定义一系列的算法也就是规则，把它们一个个封装起来，并且使它们可以相互替换。

策略模式的目的就是将算法的使用与算法的实现分离开来，我们（消除了原程序中大片的条件分支语句）

理解：就是将分支判断变为对象内的函数引用

```javascript
var strategies = {

	"S": function( salary ){

 		 return salary * 4;

  },

  "A": function( salary ){

  	return salary * 3;

  },

  "B": function( salary ){

  	return salary * 2;

  }

};

var calculateBonus = function( level, salary ){

	return strategies[ level ]( salary );

};

console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000

console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000
```



### 代理模式

常用的有虚拟代理和缓存代理

代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。

（当客户不方便直接访问一个对象或者不满足需要的时候），提供一个替身

对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之

后，再把请求转交给本体对象。提高类的内聚性，新功能放在类的外面，以后不需要时也不用修改原类

### 迭代器模式

现在流行的大部分语言如 Java、Ruby 等都已经有了内置的迭代器实现，许多浏览器也支持 JavaScript 的Array.prototype.forEach ，也就是内置的迭代函数

### 发布 — 订阅模式

发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状

态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型

来替代传统的发布 — 订阅模式。

### 命令模式

命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。JavaScript 作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了JavaScript语言之中，JavaScript 可以用高阶函数非常方便地实现命令模式，命令模式在 JavaScript语言中是一种隐形的模式。还可以选择发布订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息之后，便开始执行队列里的下一个动画。宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令

### 装饰者（decorator）模式

（通过装饰类）给对象动态地增加职责的方式称为装饰者（decorator）模式

```javascript
var plane = new Plane();

plane = new MissileDecorator( plane );

plane = new AtomDecorator( plane );

应用

window.onload = function(){

   alert (1);

}

var _onload = window.onload || function(){};

window.onload = function(){

  _onload();

  alert (2);

}
```



### 状态模式

将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化

状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的 if 、 else 条件分支语言来控制状态之间的转换。

在 button 按钮被按下的事件里，Context 也不再直接进行任何实质性的操作，而是通过

```javascript
self.currState.buttonWasPressed() 将请求委托给当前持有的状态对象去执行

var Light = function(){

  this.offLightState = new OffLightState( this );

  this.weakLightState = new WeakLightState( this );

  this.strongLightState = new StrongLightState( this );

  this.button = null;

};

Light.prototype.init = function(){

  var button = document.createElement( 'button' ),

  self = this;

  this.button = document.body.appendChild( button );

  this.button.innerHTML = '开关';

  this.currState = this.offLightState; // 设置当前状态

  this.button.onclick = function(){

    self.currState.buttonWasPressed();

  }

};


```

最后还要提供一个 Light.prototype.setState 方法，状态对象可以通过这个方法来切换 light

对象的状态。前面已经说过，状态的切换规律事先被完好定义在各个状态类中。在 Context中再

也找不到任何一个跟状态切换相关的条件分支语句：
```
Light.prototype.setState = function( newState ){

this.currState = newState;

};
```
现在可以进行一些测试：
```
var light = new Light();

light.init();
```
如果我们编写一个状态子

类时，忘记了给这个状态子类实现 buttonWasPressed 方法，则会在状态切换的时候抛出异常。因

为 Context总是把请求委托给状态对象的 buttonWasPressed 方法。

让抽象父类的抽象方法直接抛出一个异常，这个异常至少会在程序运行期间就被发现：

var State = function(){};

State.prototype.buttonWasPressed = function(){

throw new Error( '父类的 buttonWasPressed 方法必须被重写' );

};

### 适配器模式

适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本

由于接口不兼容而不能工作的两个软件实体可以一起工作。也就是解决两个格式不一致的问题

如在 JSON 格式流行之前，很多 cgi 返回的都是 XML 格式的数据，如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON的适配器

模板方式模式

模板方法模式是一种只需使用继承就可以实现的非常简单的模式。

模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常

在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺

序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

但在 JavaScript中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数

是更好的选择

### 享元模式

元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时

便可以使用享元模式.

- 一个程序中使用了大量的相似对象。
-   由于使用了大量对象，造成很大的内存开销。
-  对象的大多数状态都可以变为外部状态。
-  剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。

可以看到，文件上传的例子完全符合这四点。

享元模式的关键是**区别内部状态和外部状态**。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象

享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了

### 职责链模式

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间

的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

一系列可能会处理请求的对象被连接成一条链，请求在这些对

象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点

```javascript
Function.prototype.after = function( fn ){

  var self = this;

  return function(){

    var ret = self.apply( this, arguments );

    if ( ret === 'nextSuccessor' ){

   		 return fn.apply( this, arguments );

    }

    return ret;

  }

};

var order = order500yuan.after( order200yuan ).after( orderNormal );

order( 1, true, 500 ); // 输出：500 元定金预购，得到 100 优惠券

order( 2, true, 500 ); // 输出：200 元定金预购，得到 50 优惠券

order( 1, false, 500 ); // 输出：普通购买，无优惠券
```



### 中介者模式

中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可

### 组合模式

组合模式最大的优点在于可以一致地对待组合对象和基本对象。客户不需要知道

当前处理的是宏命令还是普通命令，只要它是一个命令，并且有 execute 方法，这个命令就可以

被添加到树中

组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种

情况。

-  表示对象的部分
- 整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分整

体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最

终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模

式中增加和删除树的节点非常方便，并且符合开放-封闭原则。

-  客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，

客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就

不用写一堆 if 、 else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，

这是组合模式最重要的能力。