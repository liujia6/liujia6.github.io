# 设计模式

## 设计原则

- 开闭原则
  - 添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性等)，而非修改已有代码(修改模块、类、方法、属性等)的方式来完成
    - ✅ 新增函数，扩展开放
    - ❎ 修改原函数，修改关闭
  - 可以理解各种库（vue、webpack）都提供插件来增强其功能
- 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。
- [里氏替换原则](https://cloud.tencent.com/developer/article/1831005)
  - 定义： 子类在被父类完全替换时，代码功能不会变化。
    - 要实现以上功能需要保证子类只扩展了父类的功能，尽量少通过重载修改，或者是使用抽象方法定义子类的实现
    - 也就是说在使用继承时，只扩展新功能，而不要重载
  - 优点
    - 减少继承带来的缺点，增强程序的健壮性，版本升级时也可以保持良好的兼容性。即使增加子类，原有的子类也可以继续运行。
    - 只有当子类可以替换掉父类,软件单位的功能不受到影响时，父类才能真正的被复用
    - 使得开放-封闭成为可能
  - 如何修改
    - 当违反该原则时，当下的继承关系实际是不合适的
      - 将原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。
- [依赖倒置原则](https://juejin.cn/post/6844904117173747726) （DIP）
  - 总纲：面向接口编程
  - 定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象
  - 设计模式的应用
    - 模板方法模式：使用该设计模式意味着子类放弃了对自己的控制权，而是改为父类通知子类。作为子类，只负责提供一些设计上的细节。
    - 观察者模式：发布者把消息推送给订阅者。
    - 回调函数：ajax 异步请求，把需要执行的操作封装在回调函数里，当数据返回后，这个回调函数才被执行。
  - IOC 与 DI
    - 依赖反转是遵守依赖倒置这个原则而提出来的一种设计模式，它引入了 IoC 容器的概念。
    - **控制反转**（IOC）是设计模式，遵从了依赖倒置原则，它引入了 IoC 容器的概念。在外部 IoC 容器内将依赖注入（在依赖注入的概念中叫注射器）
    - **依赖注入**（DI）是实现控制反转的手段：不通过 new（）的方式在类内部创建对象
    - 实现依赖注入有 3 种方式
      - 构造函数中注入
      - setter 方式注入
      - 接口注入
    - [参考](https://time.geekbang.org/column/article/177444)
  - 框架定义抽象接口让使用时面向接口实现即可，库只会提供工具方法
- [迪米特法则：又名“最少知道原则“](https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/)
  - 定义：一个对象应该对其他对象保持最少对了解
  - 解决了什么问题：尽量降低类与类之间对耦合，实现高内聚，低耦合
  - 一个类对自己以来对自己依赖的类知道的越少越好，只与必要的对象交互
  - [理解](https://juejin.cn/post/6872985439117312014)：病人给护士交钱，那么护士应该与病人交互，而不是与钱包交互，在这里，病人是护士和钱包的中介者
  - 如果你发现你的代码中有getXXX().getXXX().getXXX()……类似于这种代码，那就考虑下是不是违反迪米特法则，是不是要重构一下了
  - 设计模式的应用
    - 中介者模式：降低多个对象和类之间的通信复杂度，处理类之间的通信，支持松耦合，使代码易于维护，属于行为模式
- 接口隔离原则：客户端不应依赖它不需要的接口 interface 方法。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法

## 高内聚、低耦合

- 耦合
  - 两个模块之间如果能够独立工作，则这两个模块之间无耦合，如果两个模块是相互依赖的，则这两个模块之间有耦合
  - 例子
    - 例如 vue 组件中我们可以使用 emit 一个事件告知父组件，父组件可以通过\$emit 来接收
      - 这里通过 emit 事件降低了父子组件的耦合，事件属于组件本身的属性，我们不需要知道父组件的结构，只需要知道父组件的事件名称，相比直接调用父组件的方法，事件的耦合性更低
  - 若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。
- 内聚
  - 高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。所有内部状态和功能都是为了达到该组件的逻辑功能，提高程序的可靠性
- 如何降低耦合，提高内聚

## 设计模式

### 提高代码复用性的模式

#### 享元模式-共享来减少数量

- 当我们观察到代码中有大量相似的代码块，他们做的事情可能都是一样的，只是每次应用的对象不一样，以减少重复代码

#### 桥接模式-独立出来，然后再对接过去

- 桥接模式是将重复的逻辑按照逻辑将其抽离出来一个新的方法构造原对象
  - 将重复代码拆成多个维度（多个方法），使用时再组合，以减少重复代码

#### [模板方法模式](https://juejin.cn/post/7057026037477015583) （主要点在于抽象出公共的步骤），用函数式的写法就相当于传入一个有固定方法的类

模板方法模式 就是对同一种类型的事务，总结出他们共同的执行步骤。**是 DI 的一种实现**

- 定义抽象行为步骤
- 实现固定的抽象步骤执行
- 具体类 extends 基础行为类，实现抽象行为步骤即可生成一个新的对象

### [🍅 创建型](http://dennisgo.cn/Articles/DesignPatterns/Encapsulate.html)

#### [工厂模式-大量创建对象](https://github.com/hzlu/JS-design-pattern/tree/master/factory-pattern)

- 对不同类对创建隐藏，我们只需要对工厂下订单，并不需要知道获取对具体类是什么
- ☝️ 代码准则
  - 当有多种同类型的类。我们可以把她们的创建过程封装，使其 create 使用更加简单

```js
(function() {
  function popup(type, content, color) {
    if (this instanceof popup) {
      return new this[type](content, color);
    } else {
      return new popup(type, content, color);
    }
  }

  popup.prototype.infoPopup = function(content, color) {};
  popup.prototype.confirmPopup = function(content, color) {};
  popup.prototype.cancelPopup = function(content, color) {};

  window.popup = popup;
})();

// 外面就直接可以使用popup模块了
let infoPopup1 = popup('infoPopup', content, color);
```

#### 单例模式-全局只能有我一个（融入了日常代码中）

用一个变量来标记代码是否已经执行过了，如果执行过了就返回上次的执行结果，这样就保证了多次调用也会拿到一样的结果。

```js
let _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) return;
  install.installed = true;

  _Vue = Vue;
}
```

#### 建造者模式-精细化组合对象（融入了日常代码中）

```js
function Model1() {} // 模块1
function Model2() {} // 模块2

// 最终使用的类
function Final() {
  this.model1 = new Model1();
  this.model2 = new Model2();
}

// 使用时
var obj = new Final();
```

#### 原型模式-javaScript 的灵魂（融入了日常代码中）

原型模式最典型的应用就是 JS 本身啊，JS 的原型链就是原型模式。JS 中可以使用 Object.create 指定一个对象作为原型来创建对象:

### 提高代码质量，代码整洁度

#### 状态模式-用状态代替判断

- 常见用例
  - promise 的两种状态，状态机
- 复杂情况下对不同状态以及状态之间的转变进行定义，可以提高代码的质量，清晰度

#### 策略模式-算法工厂

- 就是将分支判断变为对象内的函数引用，对不同对情况使用对象进行封装使得逻辑更加清晰

#### 外观模式-给你的一个套餐（融入了日常代码中-封装）

- 就像 jquery 处理了浏览器的兼容性，提供一个统一简洁且易用的 API
- ☝️ 代码准则
  - 当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用及其复杂。通过外观模式，对接口进行二次封装可以隐藏其复杂性。

### 行为发送与处理者不同连接

- 提高代码扩展性

责任链模式 (opens new window)、 命令模式 (opens new window)、 中介者模式 (opens new window) 和 观察者模式 (opens new window)用于处理请求发送者和接收者之间的不同连接方式

- 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
- 命令在发送者和请求者之间建立单向连接。对请求信息更好得封装
- 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
- 观察者允许接收者动态地订阅或取消接收请求。

#### [职责链模式](https://juejin.cn/post/6854573219400122376#heading-1)-像生产线一样组织模块 （流水线）

类似于错误处理的方式，和中间件、[axios 请求拦截器 filter](http://dennisgo.cn/Articles/DesignPatterns/Extendability.html)

一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点

##### 适用场景

- 当程序需要使用不同方式处理**不同种类请求**， 而且**请求类型和顺序预先未知**时， 可以使用责任链模式。
- 当必须**按顺序执行**多个处理者时， 可以使用该模式。
- 如果**所需处理者及其顺序必须在运行时进行改变**， 可以使用责任链模式。

#### [命令模式](https://juejin.cn/post/6844903615253970951#heading-0) - 是对行为（函数）的一种封装

命令模式是一种基础模式，本意是对行为（函数）的一种封装，将行为封装为对象，以使得后续任意处理者可以了解该行为并对该行为做更多复杂的行为处理。例如对记录请求排队或者记录请求日志，以及执行可撤销的操作。

- 该模式在 JS 中是一种隐身模式，常用的高阶函数就是一种命令模式
- ☝️ 代码准则
  - 当某个函数（动作）的功能具有较多的信息记录，可以将其封装为一个高阶函数，或者对象记录其相关信息并传递给处理者

#### 观察者模式-我作为第三方转发

```js
var Observer={
    update(){
        console.log("I'm watching you")
    }
}
var Subject={
    observers:[],
    notify(){
        this.observers.forEach(function(item){
            item.update();
        }
    },
    attach(observer){
        observers.push(observer);
    }
}
```

#### 发布订阅模式

在实际使用中，我们应该也会接触到 PubSub 模式，例如 Nodejs 中的 EventEmitter、Backbone 中的事件模型、以及 jQuery 中的事件。 以 EventEmitter 为栗子，它提供了 addListener(event, listener)，removeListener(event, listener)，emit(event, [arg1], [arg2], [...]) 方法。

```js
var pubSub={
    topics:{},
    subscribe(type,fn){
        topics[type]?topics[type]++:topics[type]=1;
    }
    publish(type,...args){
        topic[type].forEach((item)=>{
            item(args)
        }
    }
}
```

##### 观察者与发布订阅的区别

- 观察者模式中主体和观察者是两者之间直接传递消息，发布-订阅模式是借助第三方来实现消息传递的，发布者和订阅者之间互不感知

![image](https://user-images.githubusercontent.com/18718461/53536375-228ba180-3b41-11e9-9737-d71f85040cfc.png)

## 其他技巧

#### 适配器模式-用适配代替更改

当我们面临接口不通用，接口参数不匹配等情况，我们可以在他外面再包一个方法，这个方法接收我们现在的名字和参数，里面调用老方法传入以前的参数形式。

#### 装饰者模式 - 更优雅地扩展需求

装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。例如 window.onload。ES7 中的装饰器语法

#### [组合模式](https://juejin.cn/post/6995851145490989070)

- 定义

  - 是一种**统一管理树形结构**的抽象方式。有点类似与树形结构的递归处理
  - 将对象组合成树形结构以表示 “部分 - 整体” 的层次结构
  - Composite 使得用户对单个对象和组合对象的使用具有一致性。

- 优势
  - 组合模式使客户可以忽略组合对象和叶对象的区别
    - 客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。
  - 组合模式可以方便地构造一棵树来表示对象的部分——整体结构。
    - 特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放——封闭原则。
- 用职责链模式提高组合模式性能
  - 在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。

#### 中介者模式 - 降低耦合性

中介者模式的作用就是解除对象与对象之间的紧耦合关系。

- 通过中介类，我们简单地传入我们的需求与自身状态，执行我们需求功能，减少与外部类之间的耦合
- 缺点是需要维护一个中介者对象，增加交互的复杂性
- ☝️ 代码准则
  - 当我们与另一个类交互时，需要抽出方法

## AOP 面向切面编程

```javascript
export default {
  around(obj, fn, beforeFn) {
    let _fn = obj[fn];
    obj[fn] = function() {
      _fn.call(this);
      let ret = beforeFn.call(this);
      _fn.call(this, ret);
    };
  },
  before(obj, fn, beforeFn) {
    let _fn = obj[fn];
    obj[fn] = function() {
      let ret = beforeFn.apply(this, arguments);
      return _fn.call(this, ret);
    };
  },
  after(obj, fn, beforeFn) {
    let _fn = obj[fn];
    obj[fn] = function() {
      let ret = _fn.apply(this, arguments);
      return beforeFn.call(this, ret);
    };
  },
};
```

## 参考

- [设计模式](http://dennisgo.cn/Articles/DesignPatterns/DesignPatterns.html)
