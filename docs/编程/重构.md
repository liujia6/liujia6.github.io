# 重构

是什么： 使用一系列重构手法，在不改变软件可观察行为的前提下调整结构

1. 好代码的检验标准就是人们是否能轻而易举地修改它

## 代码的坏味道

1. 命名

2. 重复代码

3. 过长函数

4. 过长参数列表

5. 全局数据：代码的任何一个地方都可以改变它，并且探测不到它在哪里有改变

   - 封装函数修改变量，可以知道哪里修改了改变量，可以封装一个类

6. 可变数据

   - 函数式编程
     - 如果要更新一个数据，就i返回一个新的数据副本，旧的数据保持不变
   - 如果一个变量在不同时候用于存储不用的东西，则可以使用`拆分变量`将其拆分为各自不同用途的变量，避免危险的更新操作

7. 发散式变化

   - 每次只关心一个上下文，也即：一个逻辑只涉及一个地方。修改一个逻辑的时候不需要了解其他的逻辑。每次只关心一个。
   - 修改：使用拆分阶段或者搬移函数拆分开来

8. 散弹式修改

   - 与发散式变化相反。一个逻辑修改需要在许多不同的类或者函数中修改：即拆分的太细了
   - 修改：去除多余的函数或者类，内联函数，内联类

9. 依恋情结

   - 模块之间的交互比模块内的交互多
   - 修改：将总是一起变化的东西放在一块。数据和引用这些数据的行为总是一起变化的

10. 数据泥团

    - 总是有一组经常出现的数据，都拆分了
    - 修改：将它们用对象包装起来 page、size => list:{ page,size }

11. 基本类型偏执

12. 重复的switch

    - 当你想增加一个选择分支时，必须找到所有的switch，并逐一更新。
    - 修改：以多态取代条件表达式

13. 循环语句

    - 修改：

      - 使用管道取代循环

        ```js
        const loopItems = lines
        		.slice(1)
        		.filter(line=>line.trim!=="")
        		.map(line=> line.split("."))
        		
        // 取代循环中的各种判断和操作
        ```

14. 赘余的元素

    - 没必要的类

15. 夸夸其谈通用性

    - 为没必要的扩展性考虑，添加没必要的处理

16. 临时字段

17. 过长的消息链

    - 用户向一个对象请求另一个对象，再向后者请求另一个对象，然后再。。。

    - 修改：隐藏委托关系

      ```js
      manager = aPerson.department.manager
      // => manager = aPerson.manager 
      // aPerson.manager = aPerson.departmant.manager
      ```

18. 中间人

    - 过分运用委托，中间人不干实事
    - 修改：移除中间人，使用内联函数

19. 内幕交易

    - 模块之间大量交换数据
    - 修改：
      - 搬移需要的函数、字段到模块
      - 提炼类、中间人、隐藏委托关系

20. 过大的类

21. 异曲同工的类

22. 纯数据类

    - 类只是作为控制访问读写某些字段的函数，数据容器
