# 模块化

- ES6 模块，简称 ESM
  - mjs 文件总是以 ES6 模块加载，.js 文件的加载取决于 package.json 里面 type 字段的设置。如果加了"type": "module"，则代表该项目使用 esm 模块解析
- Node.js 专用的 CommonJS 模块，简称 CJS
  - .cjs 文件总是以 CommonJS 模块加载

## CommonJS

Node.js 是`commonJS`规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module、exports、require、global`。实际使用时，用`module.exports`定义当前模块对外输出的接口，用`require`加载模块。

```javascript
// 定义模块 area.js
function area(radius) {
  return Math.PI * radius * radius;
}

// 在这里写上需要向外暴露的函数、变量
module.exports = {
  area: area,
};

// 引用自定义的模块时，参数包含路径
var math = require('./math');
math.area(2);
```

但是我们并没有直接定义 `module、exports、require`这些模块，以及 Node 的 API 文档中提到的`__filename、__dirname`。那么是从何而来呢？其实在编译的过程中，Node 对我们定义的 JS 模块进行了一次基础的包装：

```javascript
(function(exports, require, modules, __filename, __dirname)) {
  ...
})
```

这样我们便可以访问这些传入的`arguments`以及隔离了彼此的作用域。`CommonJS` 的一个模块，就是一个脚本文件。`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。

```javascript
{
  id: '...',
  exports: { ... },
  loaded: true,
  ...
}
```

首次加载后的模块会**缓存**在 require.cache 之中,是对象的**浅拷贝**，所以多次加载 require，得到的对象是同一个。

以后需要用到这个模块的时候，就会到`exports`属性上面取值。即使再次执行`require`命令，也不会再次执行该模块，而是到缓存之中取值。commonJS 用同步的方式加载模块，只有在代码执行到`require`的时候，才回去执行加载。

在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。

### exports 和 module.exports

- 在一个 node 执行一个文件时，会给这个文件内生成一个 exports 和 module 对象，
  而 module 有一个 exports 属性。
- exports 是 module.exports 的一个引用,作用相等
  - `exports = module.exports = {};`

## ESM

命名导出（每个模块多个）

```javascript
export const sqrt = Math.sqrt;

export function square(x) {
  return x * x;
}

export function diag(x, y) {
  return sqrt(square(x) + square(y));
}
```

导入

```javascript
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
// 或者
import * as lib from 'lib';
console.log(lib.square(11)); // 121console.log(lib.diag(4, 3)); // 5
```

### 默认导出只是另一个命名导出

默认导出实际上只是一个具有特殊名称`default`的命名导出。也就是说，以下两个语句是是等价的：

ECMAScript6 代码:

```javascript
export default function foo() {}
import { default as foo } from 'lib';
// 等价于
import foo from 'lib';
```

### [export 和 export default 区别](https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/模块.md)

1. 在一个文件或模块中，export、import 可以有多个，export default 仅有一个
2. 通过 export 方式导出，在导入时要加{ }，export default 则不需要
3. export 能直接导出变量表达式，export default 不行。

### [import-maps](https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html)

- 通过 import-maps 可以让浏览器识别全局模块，
- import-maps 使用 Json 的形式来定义浏览器中的全局模块
- 对于不支持 import-maps 的浏览器， 可以使用 es-module-shims 进行处理。

```html
<script type="importmap">
  {
    "importmap": {
      "vue": "https://unpkg.com/browse/vue@3.2.2/dist/vue.runtime.esm-browser.js",
      "vue-router": "https://unpkg.com/browse/vue-router@4.0.11/dist/vue-router.esm-browser.js"
    }
  }
</script>
<script type="module">
  import { createApp } from 'vue';

  const app = createApp({
    template: '<div></div>',
    data(): { counter: number } {
      return { counter: 0 };
    },
    mounted(): void {
      setInterval(() => {
        this.counter++;
      }, 1000);
    },
  });

  app.mount('#root');
</script>
```

## ES6 模块与 CommonJS 模块的差异

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

1. `CommonJS` 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
2. `ES6 Modules` 的运行机制与 `CommonJS` 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

1. 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
2. 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”

CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

## 参考

[CommonJS、AMD/CMD、ES6 Modules 以及 webpack 原理浅析](https://github.com/muwoo/blogs/issues/28) .

[ES6 Modules(模块)系统及语法详解](https://www.html.cn/archives/6974)
