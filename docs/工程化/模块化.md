# 模块化

[ES6 Modules(模块)系统及语法详解](https://www.html.cn/archives/6974)

-  ES6 模块，简称 ESM

-  Node.js 专用的 CommonJS 模块，简称 CJS

## CommonJS

Node.js是`commonJS`规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module、exports、require、global`。实际使用时，用`module.exports`定义当前模块对外输出的接口，用`require`加载模块。

```javascript
// 定义模块 area.js
function area(radius) {
  return Math.PI * radius * radius;
}

// 在这里写上需要向外暴露的函数、变量
module.exports = { 
  area: area
}

// 引用自定义的模块时，参数包含路径
var math = require('./math');
math.area(2);
```

但是我们并没有直接定义 `module、exports、require`这些模块，以及 Node 的 API 文档中提到的`__filename、__dirname`。那么是从何而来呢？其实在编译的过程中，Node 对我们定义的 JS 模块进行了一次基础的包装：

```javascript
(function(exports, require, modules, __filename, __dirname)) {
  ...
})
```

这样我们便可以访问这些传入的`arguments`以及隔离了彼此的作用域。`CommonJS` 的一个模块，就是一个脚本文件。`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。

```javascript
{
  id: '...',
  exports: { ... },
  loaded: true,
  ...
}
```

首次加载后的模块会**缓存**在require.cache之中,是对象的**浅拷贝**，所以多次加载require，得到的对象是同一个。

以后需要用到这个模块的时候，就会到`exports`属性上面取值。即使再次执行`require`命令，也不会再次执行该模块，而是到缓存之中取值。commonJS用同步的方式加载模块，只有在代码执行到`require`的时候，才回去执行加载。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。

1. exports和module.exports
1. 在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，
    而module有一个exports属性。
    exports = module.exports = {};
2. 关于 export 和export default
  1. export与export default均可用于导出常量、函数、文件、模块等

    在一个文件或模块中，export、import可以有多个，export default仅有一个
    通过export方式导出，在导入时要加{ }，export default则不需要
    export能直接导出变量表达式，export default不行。

### [export和export default](https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/模块.md)

## ESM

export default是**唯一**的，导出没有{}，如export default a，import a from

export可以是**多个**，且要加{}，如export {a，b}，import {a，b} from

exports 是 module.exports 的一个引用,作用相等

命名导出（每个模块多个）

```javascript
export const sqrt = Math.sqrt;

export function square(x) {
  return x * x;
}

export function diag(x, y) {
  return sqrt(square(x) + square(y));
}
```

导入

```javascript
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
// 或者
import * as lib from 'lib';
console.log(lib.square(11)); // 121console.log(lib.diag(4, 3)); // 5
```

#### 默认导出只是另一个命名导出

默认导出实际上只是一个具有特殊名称`default`的命名导出。也就是说，以下两个语句是是等价的：

ECMAScript6 代码:

```javascript
export default function foo(){} 
import { default as foo } from 'lib';
// 等价于
import foo from 'lib';
```

## ES6 模块与 CommonJS 模块的差异

#### CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

1. `CommonJS` 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
2. `ES6 Modules` 的运行机制与 `CommonJS` 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

#### CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

1. 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
2. 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”

CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

参考

 [CommonJS、AMD/CMD、ES6 Modules 以及 webpack 原理浅析](https://github.com/muwoo/blogs/issues/28) .

mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，

.js文件的加载取决于package.json里面type字段的设置。如果加了"type": "module"，则代表该项目使用esm模块解析


