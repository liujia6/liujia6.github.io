import{_ as n,c as s,o as a,a as e}from"./app-BsmYACjM.js";const t={},l=e(`<h1 id="bash-入门" tabindex="-1"><a class="header-anchor" href="#bash-入门"><span>Bash 入门</span></a></h1><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h2><p>Bash 没有数据类型的概念，所有的变量值都是字符串</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>variable=value</td><td>变量声明</td></tr><tr><td>\${!string*}或\${!string@}</td><td>返回所有匹配给定字符串 string 的变量名。</td></tr><tr><td>a=z</td><td>变量 a 赋值为字符串 z</td></tr><tr><td>c=&quot;a string and $b&quot;</td><td>引用其他变量的值</td></tr><tr><td>e=$(ls -l foo.txt) 或者<code>ls -l foo.txt</code></td><td>是命令的执行结果，$(...)可以嵌套，比如$(ls $(pwd))。</td></tr><tr><td></td><td>反斜杠可以出书</td></tr><tr><td>f=$((5 * 7))</td><td>是数学运算的结果</td></tr><tr><td>$foo</td><td>读取变量 foo</td></tr><tr><td>\${foo}</td><td>也表示变量，可以用于变量名与其他字符连用的情况</td></tr><tr><td>unset foo 或 foo=&#39;&#39;或 foo=</td><td>删除一个变量</td></tr><tr><td>export</td><td>列出环境变量</td></tr><tr><td>$?</td><td>上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是 0，表示上一个命令执行成功；如果是非零，上一个命令执行失败</td></tr><tr><td>$$</td><td>当前 Shell 的进程 ID，可以用来命名临时文件</td></tr><tr><td>$_</td><td>上一个命令的最后一个参数</td></tr><tr><td>$!</td><td>最近一个后台执行的异步命令的进程 ID</td></tr><tr><td>$0</td><td>当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）</td></tr><tr><td>$-</td><td>当前 Shell 的启动参数。</td></tr><tr><td>$@和$#</td><td>脚本的参数数量</td></tr><tr><td>\${varname:-word}</td><td>如果变量 varname 存在且不为空，则返回它的值，否则返回 word</td></tr><tr><td>\${varname:=word}</td><td>如果变量 varname 存在且不为空，则返回它的值，否则将它设为 word，并且返回 word</td></tr><tr><td>\${varname:+word}</td><td>如果变量名存在且不为空，则返回 word，否则返回空值.测试变量是否存在</td></tr><tr><td>\${varname:?message}</td><td>如果变量 varname 存在且不为空，则返回它的值，否则打印出 varname: message，并中断脚本的执行。如果省略了 message，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义</td></tr></tbody></table><h2 id="环境变量" tabindex="-1"><a class="header-anchor" href="#环境变量"><span>环境变量</span></a></h2><ul><li>/etc/profile <ul><li>系统级别的环境变量</li><li>/etc/profile 会首先执行/etc/profile.d/目录下的所有*.sh 文件。</li><li>需要注销系统才能生效</li></ul></li><li>～/.bashrc 文件值对当前用户有用 <ul><li>~/.bashrc ~/bash_file 是当前用户下对配置信息。</li><li>修改后用 source 命令更新</li></ul></li></ul><h3 id="export-set-env-declare-的区别" tabindex="-1"><a class="header-anchor" href="#export-set-env-declare-的区别"><span>export/set/env/declare 的区别</span></a></h3><ul><li>env：显示当前<strong>用户</strong>的<strong>环境变量</strong>/usr/bin/env，但不会显示其<strong>自定义变量</strong>。</li><li>export：功能同 env 一样，也是显示当前用户的环境变量，只不过该命令的输出是按<strong>变量名进行排序</strong>的。</li><li>declare：显示当前 Shell 中定义的所有变量，包括用户的<strong>环境变量和自定义变量</strong>，该命令的输出按变量名进行排序。</li><li>set：功能同 declare 一样，显示当前 Shell 中定义的所有变量，包括用户的环境变量和自定义变量。</li></ul><p>根据上面的说明，我们可以得出下面的结论：</p><ul><li>env 和 export 显示的是环境变量。</li><li>set 和 declare 显示的是环境变量和自定义变量。</li></ul><p>要查看全局变量，可以使用 env 或 printenv 命令</p><p>命令 env、printenv 和 set 之间的差异很细微。set 命令会显示出全局变量、局部变量以 及用户定义变量。它还会按照字母顺序对结果进行排序。env 和 printenv 命令同 set 命 令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。在这 种情况下，env 和 printenv 的输出是重复的。不过 env 命令有一个 printenv 没有的功能， 这使得它要更有用一些。</p><p>局部环境变量用的是小写字母 系统环境变量都是大写字母。</p><table><thead><tr><th>header 1</th><th>header 2</th></tr></thead><tbody><tr><td>printenv HOME</td><td>显示个别环境变量的值，</td></tr><tr><td>echo $HOME</td><td>引用某个环境变量的</td></tr></tbody></table><h2 id="declare" tabindex="-1"><a class="header-anchor" href="#declare"><span>declare</span></a></h2><p>declare 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p><p>declare 命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的 set 命令</p><h2 id="shellscript" tabindex="-1"><a class="header-anchor" href="#shellscript"><span>shellScript</span></a></h2><p>login shell</p><ul><li>通过完整登录流程是运行的 shell <ul><li>读取 etc/profile 文件</li><li>读取 etc/profile.d/.sh 脚本（PATH/USER/HOSTNAME/HISTSIZE 等）</li><li>读取/etc/profile.d/*.sh(颜色、语言、指令别名)</li><li>~/.bash_profile（用户个性化配置，常用软件的 path）、~/bash_login、~/.profile【只依次读取其中一个】</li><li>~/.bash_rc、/etc/bashrc</li><li>使用 source 指令重新加载</li></ul></li></ul><p>non-login shell</p><ul><li>不需要登录即可运行的 shell，如 su，和原 bash 下的新 bash 动作 <ul><li>~/.bashrc、/etc/bashrc</li><li>读取/etc/profile.d/*.sh(颜色、语言、指令别名)</li><li>~/.bash_logout （退出登录时运行、执行备份、缓存、临时文件清理的任务）</li></ul></li></ul><h3 id="shebang" tabindex="-1"><a class="header-anchor" href="#shebang"><span>Shebang</span></a></h3><ul><li><p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p></li><li><p><code>#!</code>后面就是脚本解释器的位置，Bash 脚本的解释器一般是/bin/sh 或/bin/bash。</p></li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token comment"># 或者</span></span>
<span class="line"><span class="token comment">#!/bin/bash</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有 Shebang 行的时候，可以直接调用执行。 <code>./script.sh</code> 如果没有 Shebang 行，就只能手动将脚本传给解释器来执行 <code>bash ./script.sh</code> 或者<code>/bin/sh ./script.sh</code></p><h3 id="source-命令" tabindex="-1"><a class="header-anchor" href="#source-命令"><span>source 命令</span></a></h3><ol><li>执行一个脚本，通常用于重新加载一个配置文件.source .bashrc</li><li>在脚本内部加载外部库。<code>source ./lib.sh</code></li></ol><h3 id="权限" tabindex="-1"><a class="header-anchor" href="#权限"><span>权限</span></a></h3><p>chmod</p><ul><li><p>脚本需要有执行权限才能执行</p></li><li><p>访问权限分为文件和目录</p></li><li><p>文件或目录的访问权限分为只读（r），可写（w）和可执行（x）三种：以文件为例，文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限</p></li><li><p>有三种不同类型的用户可对文件或目录进行访问：文件所有者，同一用户组用户和其他用户。所有者一般是文件的创建者。</p></li><li><p>权限参数 mode 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行，所以权限位数字表示为 0o666，转换十进制表示为 438。</p></li></ul><p><img src="https://fishc.com.cn/forum.php?mod=image&amp;aid=41231&amp;size=400x300&amp;key=51bb87ad6e2579a8&amp;type=1" alt="搜狗截图20151223035154.png"><img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3e70d6486d6fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment"># 给所有用户执行权限</span></span>
<span class="line">$ <span class="token function">chmod</span> +x script.sh</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 给所有用户读权限和执行权限</span></span>
<span class="line">$ <span class="token function">chmod</span> +rx script.sh</span>
<span class="line"><span class="token comment"># 或者</span></span>
<span class="line">$ <span class="token function">chmod</span> <span class="token number">755</span> script.sh <span class="token comment"># 常用755权限</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 只给脚本拥有者读权限和执行权限</span></span>
<span class="line">$ <span class="token function">chmod</span> u+rx script.sh</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sh 执行脚本命令没有权限也能正常执行</p><ul><li>sh+脚本名称，可以不必事先设定 shell 的执行权限。因为这个是将 test.sh 作为参数传给 sh(bash)命令来执行的。这时不是 test.sh 自己来执行，而是被人家调用执行，所以不要执行权限。</li><li>如果直接运行./test.sh，就会报权限问题</li></ul><h3 id="echo-输出" tabindex="-1"><a class="header-anchor" href="#echo-输出"><span>echo 输出</span></a></h3><ul><li>echo -n 取消行尾的换行</li><li>echo -e 解释特殊字符</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment"># 加上斜杠/会将下一行跟当前行放在一起解释。</span></span>
<span class="line"><span class="token builtin class-name">echo</span> foo <span class="token punctuation">\\</span></span>
<span class="line">bar</span>
<span class="line"><span class="token comment"># 等同于 echo foo bar</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span><a href="https://wangdoc.com/bash/stack.html" target="_blank" rel="noopener noreferrer">目录</a></span></a></h2><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>cd -</td><td>返回前一次的目录</td></tr><tr><td>pushd dirname</td><td>进入目录 dirname，并将该目录放入堆栈</td></tr><tr><td>popd</td><td>会移除堆栈的顶部记录，并进入新的堆栈顶部目录</td></tr><tr><td>popd -n</td><td>仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录</td></tr><tr><td>pushd +3</td><td>从栈顶算起的 3 号目录（从 0 开始），移动到栈顶</td></tr><tr><td>dirs</td><td>显示目录堆栈的内容</td></tr></tbody></table><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展"><span>扩展</span></a></h2><table><thead><tr><th>命令</th><th>目录</th></tr></thead><tbody><tr><td>~</td><td>/home/me，自动扩展成当前用户的主目录</td></tr><tr><td>~foo</td><td>/home/foo</td></tr><tr><td>~root</td><td>/root</td></tr></tbody></table><h3 id="匹配" tabindex="-1"><a class="header-anchor" href="#匹配"><span>匹配</span></a></h3><table><thead><tr><th>字符</th><th>匹配</th></tr></thead><tbody><tr><td><code>\\*</code></td><td>任意数量的任意字符,只匹配当前目录，不会匹配子目录。例如子目录有一个 a.txt 用<code>\\*/\\*.txt</code>表示。</td></tr><tr><td>?</td><td>任意单个字符。例如 ls ??.txt 表示匹配当前目录下的 ab.txt</td></tr><tr><td>globstar 参数：<code>\\*\\*</code></td><td>零个或多个子目录,<code>\\*\\*/\\*.txt</code>表示匹配当前和所有子目录下的 txt 文件</td></tr></tbody></table><h2 id="转义" tabindex="-1"><a class="header-anchor" href="#转义"><span>转义</span></a></h2><p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要</p><ul><li>单引号： <ul><li>用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（*）、美元符号（$）、反斜杠（\\）等。</li></ul></li><li>双引号 <ul><li>里面不会进行文件名扩展.三个特殊字符除外：美元符号（$）、反引号（\`）和反斜杠（\\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。换行符在双引号之中就失去了这种特殊作用，只用来换行，所以可以输入多行。echo 命令会将换行符原样输出，显示的时候正常解释为换行。</li></ul></li></ul><h2 id="here-字符串-here-string" tabindex="-1"><a class="header-anchor" href="#here-字符串-here-string"><span>Here 字符串（Here string）</span></a></h2><p>使用三个小于号（<code>&lt;&lt;&lt;</code>）表示 Here 字符串。</p><p><code>&lt;&lt;&lt; string</code> 它的作用是将<code>string通过标准输入，传递给命令</code>。</p><p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 cat 命令只接受标准输入传入的字符串。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">&#39;hi there&#39;</span></span>
<span class="line"><span class="token comment"># 等同于</span></span>
<span class="line">$ <span class="token builtin class-name">echo</span> <span class="token string">&#39;hi there&#39;</span> <span class="token operator">|</span> <span class="token function">cat</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="环境变量-1" tabindex="-1"><a class="header-anchor" href="#环境变量-1"><span>环境变量</span></a></h3><ul><li>set 命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。</li><li>env 命令或 printenv 命令，可以显示所有环境变量。</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">$ <span class="token function">printenv</span> <span class="token environment constant">PATH</span></span>
<span class="line"><span class="token comment"># 或者</span></span>
<span class="line">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span></span>
<span class="line">注意，printenv命令后面的变量名，不用加前缀$。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="字符串操作" tabindex="-1"><a class="header-anchor" href="#字符串操作"><span>字符串操作</span></a></h2><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>获取字符串长度</td><td>\${#varname}</td></tr><tr><td>脚本的参数个数</td><td>$#</td></tr><tr><td>字符串提取子串：返回变量$varname 的子字符串，从位置 offset 开始（从 0 开始计算），长度为 length</td><td>\${varname:offset:length}</td></tr><tr><td>如果 pattern 匹配变量 variable 的<code>开头</code>， 删除<code>最短</code>匹配（非贪婪匹配）的部分，返回剩余部分</td><td>\${variable#pattern}</td></tr><tr><td>如果 pattern 匹配变量 variable 的开头，删除<code>最长</code>匹配（贪婪匹配）的部分，返回剩余部分</td><td>\${variable##pattern}</td></tr><tr><td>将头部匹配的部分，替换成其他内容 replace</td><td>\${variable/#pattern/string}</td></tr><tr><td>如果 pattern 匹配变量 variable 的结尾,删除最短匹配（非贪婪匹配）的部分，返回剩余部分</td><td>\${variable%pattern}</td></tr><tr><td>如果 pattern 匹配变量 variable 的结尾， 删除最长匹配（贪婪匹配）的部分，返回剩余部分</td><td>\${variable%%pattern}</td></tr><tr><td>将尾部匹配的部分，替换成其他内容</td><td>\${variable/%pattern/string}</td></tr><tr><td>如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配</td><td>\${variable/pattern/string}</td></tr><tr><td>如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换</td><td>\${variable//pattern/string}</td></tr><tr><td>变量转为大写</td><td>\${varname^^}</td></tr><tr><td>变量转为小写</td><td>\${varname,,}</td></tr></tbody></table><p>记忆总结：</p><ol><li><code>\\#</code> 是头部匹配</li><li>% 是尾部匹配</li><li>单个%或#是非贪婪匹配，两个是贪婪匹配</li><li>没有指定都是直接删除匹配部分</li></ol><h2 id="条件判断" tabindex="-1"><a class="header-anchor" href="#条件判断"><span>条件判断</span></a></h2><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token keyword">if</span> commands<span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line">commands</span>
<span class="line"><span class="token punctuation">[</span>elif commands<span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line">commands<span class="token punctuation">..</span>.<span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">[</span>else</span>
<span class="line">commands<span class="token punctuation">]</span></span>
<span class="line"><span class="token keyword">fi</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="test-命令" tabindex="-1"><a class="header-anchor" href="#test-命令"><span>test 命令</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment"># 写法一</span></span>
<span class="line"><span class="token builtin class-name">test</span> expression</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 写法二，[]必须有空格</span></span>
<span class="line"><span class="token punctuation">[</span> expression <span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 写法三，[]必须有空格，还支持正则</span></span>
<span class="line"><span class="token punctuation">[</span><span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-a</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-b</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是一个块（设备）文件，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-c</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是一个字符（设备）文件，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-d</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是一个目录，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-e</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是一个普通文件，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-g</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且设置了组 ID，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-G</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且属于有效的组 ID，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-h</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是符号链接，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-k</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且设置了它的“sticky bit”，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-L</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是一个符号链接，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-N</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且自上次读取后已被修改，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-O</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且属于有效的用户 ID，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-p</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且是一个命名管道，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-r</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在并且可读（当前用户有可读权限），则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-s</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在且其长度大于零，则为true。</span>
<span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-S</span> <span class="token function">file</span> <span class="token punctuation">]</span>：如果 <span class="token function">file</span> 存在且是一个网络 socket，则为true。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string"><span>string</span></a></h3><ul><li>[ string ]：如果 string 不为空（长度大于 0），则判断为真。</li><li>[ -n string ]：如果字符串 string 的长度大于零，则判断为真。</li><li>[ -z string ]：如果字符串 string 的长度为零，则判断为真。</li><li>[ string1 = string2 ]：如果 string1 和 string2 相同，则判断为真。</li><li>[ string1 == string2 ] 等同于[ string1 = string2 ]。</li><li>[ string1 != string2 ]：如果 string1 和 string2 不相同，则判断为真。</li><li>[ string1 &#39;&gt;&#39; string2 ]：如果按照字典顺序 string1 排列在 string2 之后，则判断为真。</li><li>[ string1 &#39;&lt;&#39; string2 ]：如果按照字典顺序 string1 排列在 string2 之前，则判断为真。</li></ul><h3 id="number" tabindex="-1"><a class="header-anchor" href="#number"><span>number</span></a></h3><ul><li>[ integer1 -eq integer2 ]：如果 integer1 等于 integer2，则为 true。</li><li>[ integer1 -ne integer2 ]：如果 integer1 不等于 integer2，则为 true。</li><li>[ integer1 -le integer2 ]：如果 integer1 小于或等于 integer2，则为 true。</li><li>[ integer1 -lt integer2 ]：如果 integer1 小于 integer2，则为 true。</li><li>[ integer1 -ge integer2 ]：如果 integer1 大于或等于 integer2，则为 true。</li><li>[ integer1 -gt integer2 ]：如果 integer1 大于 integer2，则为 true。</li></ul><h3 id="正则判断" tabindex="-1"><a class="header-anchor" href="#正则判断"><span>正则判断</span></a></h3><p>[[ string1 =~ regex ]]</p><h3 id="逻辑判断" tabindex="-1"><a class="header-anchor" href="#逻辑判断"><span>逻辑判断</span></a></h3><ul><li>AND 运算：&amp;&amp;，或者 -a</li><li>OR 运算：||，或者-o</li><li>NOT 运算：!</li></ul><h3 id="算术判断" tabindex="-1"><a class="header-anchor" href="#算术判断"><span>算术判断</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">3</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line"><span class="token builtin class-name">echo</span> <span class="token string">&quot;true&quot;</span></span>
<span class="line"><span class="token keyword">fi</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="循环" tabindex="-1"><a class="header-anchor" href="#循环"><span>循环</span></a></h2><h3 id="while-循环" tabindex="-1"><a class="header-anchor" href="#while-循环"><span>while 循环</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">while condition; do</span>
<span class="line">commands</span>
<span class="line">done</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="util-循环" tabindex="-1"><a class="header-anchor" href="#util-循环"><span>util 循环</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">until condition; do</span>
<span class="line">commands</span>
<span class="line">done</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="for-in-循环" tabindex="-1"><a class="header-anchor" href="#for-in-循环"><span>for...in 循环</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">for i in *.png; do</span>
<span class="line">ls -l $i</span>
<span class="line">done</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">for (( i=0; i&lt;5; i=i+1 )); do</span>
<span class="line">echo $i</span>
<span class="line">done</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h2><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment">#创建函数</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 第一种</span></span>
<span class="line"><span class="token function-name function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token comment"># codes</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment"># 第二种</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function-name function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token comment"># codes</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 函数调用</span></span>
<span class="line">fn <span class="token variable">$1</span> <span class="token variable">$2</span></span>
<span class="line"><span class="token comment"># 表示fn调用并传参$1和$2</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 使用函数输出</span></span>
<span class="line"><span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token string">&#39;func1&#39;</span>或者result<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>func1<span class="token variable">)</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除一个函数，可以使用 unset 命令。<code>unset -f functionName</code></p><h2 id="函数变量" tabindex="-1"><a class="header-anchor" href="#函数变量"><span>函数变量</span></a></h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$1~$9，\${10}</td><td>函数的第一个到第 9 个的参数。第 10 个参数</td></tr><tr><td>$0</td><td>函数所在的脚本名。</td></tr><tr><td>$#</td><td>函数的参数总数。</td></tr><tr><td>$@</td><td>函数的全部参数，参数之间使用空格分隔。</td></tr><tr><td>$*</td><td>函数的全部参数，参数之间使用变量$IFS 值的第一个字符分隔，默认为空格，但是可以自定义。</td></tr></tbody></table><p>local foo 说明是函数内的局部变量，否则是属于全局变量</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><h2 id="新建数组" tabindex="-1"><a class="header-anchor" href="#新建数组"><span>新建数组</span></a></h2><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token assign-left variable">ARRAY</span><span class="token operator">=</span><span class="token punctuation">(</span>value1 value2 <span class="token punctuation">..</span>. valueN<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 等同于</span></span>
<span class="line"></span>
<span class="line"><span class="token assign-left variable">ARRAY</span><span class="token operator">=</span><span class="token punctuation">(</span></span>
<span class="line">value1</span>
<span class="line">value2</span>
<span class="line">value3</span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">$ <span class="token assign-left variable">mp3s</span><span class="token operator">=</span><span class="token punctuation">(</span> *.mp3 <span class="token punctuation">)</span> // 将当前目录的所有 MP3 文件，放进一个数组</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数组操作" tabindex="-1"><a class="header-anchor" href="#数组操作"><span>数组操作</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token comment"># 读取数组某个位置上元素，不指定默认输出第一个元素</span></span>
<span class="line"><span class="token variable">\${array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>}</span></span>
<span class="line"><span class="token comment"># 循环数组元素</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token string">&quot;<span class="token variable">\${names<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>&quot;</span><span class="token punctuation">;</span> <span class="token keyword">do</span></span>
<span class="line"><span class="token builtin class-name">echo</span> <span class="token variable">$i</span></span>
<span class="line"><span class="token keyword">done</span></span>
<span class="line"><span class="token comment"># 赋值数组</span></span>
<span class="line"><span class="token assign-left variable">hobbies</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token string">&quot;<span class="token variable">\${activities<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>&quot;</span> <span class="token punctuation">)</span></span>
<span class="line"><span class="token comment"># 获取数组的长度</span></span>
<span class="line"><span class="token variable">\${<span class="token operator">#</span>array<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span></span>
<span class="line"><span class="token variable">\${<span class="token operator">#</span>array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span></span>
<span class="line"><span class="token comment"># 提取数组成员</span></span>
<span class="line"><span class="token variable">\${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token operator">:</span>position<span class="token operator">:</span>length}</span></span>
<span class="line"><span class="token comment"># push成员</span></span>
<span class="line"><span class="token assign-left variable">foo</span><span class="token operator">+=</span><span class="token punctuation">(</span>d e f<span class="token punctuation">)</span></span>
<span class="line"><span class="token comment"># 删除成员</span></span>
<span class="line"><span class="token builtin class-name">unset</span> foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向"><span>重定向</span></a></h2><p><a href="http://c.biancheng.net/view/942.html" target="_blank" rel="noopener noreferrer">Linux Shell 重定向（输入输出重定向）精讲</a></p><table><thead><tr><th>命令</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>echo &gt; file</td><td>echo 123 &gt; a.txt</td><td>输出重定向到 a.txt 文件</td></tr><tr><td>echo &gt;&gt; file</td><td>echo 123 &gt;&gt; a.txt</td><td>追加 123 到 a.txt 文件</td></tr><tr><td>&amp;&gt;</td><td>./a.sh &amp;&gt; a.txt</td><td>正常重定向不会输出错误，错误会在控制台上出现，而<code>&amp;&gt;</code> 符号将所有的输出都会发送到同一个位置，包括错误输出</td></tr><tr><td>dev/null</td><td>ls -al &gt; /dev/null</td><td></td></tr><tr><td>2&gt;</td><td>ls -al badfile 2&gt; test4</td><td>只重定向错误消息</td></tr><tr><td>|</td><td>echo &#39;yes&#39; |</td><td>表示管道，上一条命令的输出，作为下一条命令参数，如 echo &#39;yes&#39;</td></tr></tbody></table><h2 id="后台作业" tabindex="-1"><a class="header-anchor" href="#后台作业"><span>后台作业</span></a></h2><p>./a.sh &amp; 加上一个&amp;号即可让脚本在后台作业二控制台可以继续输入</p><h2 id="sed-编辑器" tabindex="-1"><a class="header-anchor" href="#sed-编辑器"><span>sed 编辑器</span></a></h2><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>echo &quot;This is a test&quot; | sed &#39;s/test/big test/&#39;</td><td>s 命令会用斜线间指定的第二个文本字符串来替换第 一个文本字符串模式。在本例中是 big test 替换了 test</td></tr><tr><td>sed &#39;s/dog/cat/&#39; data1.txt</td><td>将 data1.txt 文件中的 dog 变成 cat</td></tr><tr><td>sed -e &#39;s/brown/green/; s/dog/cat/&#39; data1.txt</td><td>；分隔多个 sed 命令</td></tr></tbody></table><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">s/pattern/replacement/flags 有4种可用的替换标记：</span>
<span class="line">数字，表明新文本将替换第几处模式匹配的地方；</span>
<span class="line">g，表明新文本将会替换所有匹配的文本；</span>
<span class="line">p，表明原先行的内容要打印出来；</span>
<span class="line">w file，将替换的结果写到文件中。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="grep" tabindex="-1"><a class="header-anchor" href="#grep"><span>grep</span></a></h3><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>grep linux ./ -rn</td><td>在当前文件夹下查找包含 linux 的行</td></tr><tr><td>grep match_pattern file_name</td><td>在文件中搜索一个单词，命令会返回一个包含**“match_pattern”**的文本行：</td></tr><tr><td></td><td></td></tr></tbody></table><p>参考</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484810&amp;idx=1&amp;sn=0b622ae617b863ef1cc3a32c17b8b755&amp;chksm=cea24a41f9d5c357199073c1e4692b7da7dcbd1809cf634a6cfec8c64c12250efc5274992f06&amp;token=1082669959&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">快速入门大厂后端面试必备的 Shell 编程</a></li></ul>`,104),i=[l];function p(r,c){return a(),s("div",null,i)}const o=n(t,[["render",p],["__file","bash.html.vue"]]),u=JSON.parse('{"path":"/dev-ops/bash.html","title":"Bash 入门","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[]},{"level":2,"title":"环境变量","slug":"环境变量","link":"#环境变量","children":[{"level":3,"title":"export/set/env/declare 的区别","slug":"export-set-env-declare-的区别","link":"#export-set-env-declare-的区别","children":[]}]},{"level":2,"title":"declare","slug":"declare","link":"#declare","children":[]},{"level":2,"title":"shellScript","slug":"shellscript","link":"#shellscript","children":[{"level":3,"title":"Shebang","slug":"shebang","link":"#shebang","children":[]},{"level":3,"title":"source 命令","slug":"source-命令","link":"#source-命令","children":[]},{"level":3,"title":"权限","slug":"权限","link":"#权限","children":[]},{"level":3,"title":"echo 输出","slug":"echo-输出","link":"#echo-输出","children":[]}]},{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":2,"title":"扩展","slug":"扩展","link":"#扩展","children":[{"level":3,"title":"匹配","slug":"匹配","link":"#匹配","children":[]}]},{"level":2,"title":"转义","slug":"转义","link":"#转义","children":[]},{"level":2,"title":"Here 字符串（Here string）","slug":"here-字符串-here-string","link":"#here-字符串-here-string","children":[{"level":3,"title":"环境变量","slug":"环境变量-1","link":"#环境变量-1","children":[]}]},{"level":2,"title":"字符串操作","slug":"字符串操作","link":"#字符串操作","children":[]},{"level":2,"title":"条件判断","slug":"条件判断","link":"#条件判断","children":[{"level":3,"title":"test 命令","slug":"test-命令","link":"#test-命令","children":[]},{"level":3,"title":"string","slug":"string","link":"#string","children":[]},{"level":3,"title":"number","slug":"number","link":"#number","children":[]},{"level":3,"title":"正则判断","slug":"正则判断","link":"#正则判断","children":[]},{"level":3,"title":"逻辑判断","slug":"逻辑判断","link":"#逻辑判断","children":[]},{"level":3,"title":"算术判断","slug":"算术判断","link":"#算术判断","children":[]}]},{"level":2,"title":"循环","slug":"循环","link":"#循环","children":[{"level":3,"title":"while 循环","slug":"while-循环","link":"#while-循环","children":[]},{"level":3,"title":"util 循环","slug":"util-循环","link":"#util-循环","children":[]},{"level":3,"title":"for...in 循环","slug":"for-in-循环","link":"#for-in-循环","children":[]}]},{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[]},{"level":2,"title":"函数变量","slug":"函数变量","link":"#函数变量","children":[]},{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":2,"title":"新建数组","slug":"新建数组","link":"#新建数组","children":[{"level":3,"title":"数组操作","slug":"数组操作","link":"#数组操作","children":[]}]},{"level":2,"title":"重定向","slug":"重定向","link":"#重定向","children":[]},{"level":2,"title":"后台作业","slug":"后台作业","link":"#后台作业","children":[]},{"level":2,"title":"sed 编辑器","slug":"sed-编辑器","link":"#sed-编辑器","children":[{"level":3,"title":"grep","slug":"grep","link":"#grep","children":[]}]}],"git":{"updatedTime":1717633708000,"contributors":[{"name":"liujia6","email":"liujia11@qianxin.com","commits":1}]},"filePathRelative":"dev-ops/bash.md"}');export{o as comp,u as data};
