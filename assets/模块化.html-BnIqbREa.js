import{_ as s,c as n,o as a,a as e}from"./app-BsmYACjM.js";const p={},t=e(`<h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化"><span>模块化</span></a></h1><p>主流的模块化规范包括CommonJS、AMD、CMD、UMD和ESM这几种</p><ul><li>Node.js 专用的 CommonJS 模块，简称 CJS <ul><li>.cjs 文件总是以 CommonJS 模块加载</li></ul></li><li>ES6 模块，简称 ESM， <ul><li>ESM是依赖于ES静态模块结构的一种更为高效的模块规范；</li><li>mjs 文件总是以 ES6 模块加载，.js 文件的加载取决于 package.json 里面 type 字段的设置。如果加了&quot;type&quot;: &quot;module&quot;，则代表该项目使用 esm 模块解析</li></ul></li><li>UMD会判断环境兼容支持CommonJS、AMD和CMD几种格式，并支持浏览器window附加变量。</li><li>CMD 和 AMD 一样，都是用于浏览器端的异步模块定义规范，两者主要区别是对依赖的处理时机 <ul><li>CMD是执行到相应依赖时再加载依赖，最常见的实践是sea.js。</li><li>AMD要求先加载依赖，再执行当前模块逻辑，最常见的实践是require.js</li></ul></li></ul><h2 id="commonjs" tabindex="-1"><a class="header-anchor" href="#commonjs"><span>CommonJS</span></a></h2><p>Node.js 是<code>commonJS</code>规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module、exports、require、global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口，用<code>require</code>加载模块。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token comment">// 定义模块 area.js</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">radius</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 在这里写上需要向外暴露的函数、变量</span></span>
<span class="line">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">area</span><span class="token operator">:</span> area</span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 引用自定义的模块时，参数包含路径</span></span>
<span class="line"><span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./math&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">math<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是我们并没有直接定义 <code>module、exports、require</code>这些模块，以及 Node 的 API 文档中提到的<code>__filename、__dirname</code>。那么是从何而来呢？其实在编译的过程中，Node 对我们定义的 JS 模块进行了一次基础的包装：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> modules<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token operator">...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们便可以访问这些传入的<code>arguments</code>以及隔离了彼此的作用域。<code>CommonJS</code> 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;...&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">exports</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">loaded</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token operator">...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首次加载后的模块会<strong>缓存</strong>在 require.cache 之中,是对象的<strong>浅拷贝</strong>，所以多次加载 require，得到的对象是同一个。</p><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。commonJS 用同步的方式加载模块，只有在代码执行到<code>require</code>的时候，才回去执行加载。</p><p>在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><h3 id="exports-和-module-exports" tabindex="-1"><a class="header-anchor" href="#exports-和-module-exports"><span>exports 和 module.exports</span></a></h3><ul><li>在一个 node 执行一个文件时，会给这个文件内生成一个 exports 和 module 对象， 而 module 有一个 exports 属性。</li><li>exports 是 module.exports 的一个引用,作用相等 <ul><li><code>exports = module.exports = {};</code>，辅助 module.exports 添加内容用的，尽量使用 module.exports ,以免因为各种赋值导致的混乱</li></ul></li></ul><h2 id="esm" tabindex="-1"><a class="header-anchor" href="#esm"><span>ESM</span></a></h2><p>对于 ESM，在运行任何代码之前，你首先需要建立整个模块依赖的关系图。也就是说，建立关系图时变量是还没有值的，因为代码都还没运行。</p><h3 id="esm-原理" tabindex="-1"><a class="header-anchor" href="#esm-原理"><span><a href="https://segmentfault.com/a/1190000014318751" target="_blank" rel="noopener noreferrer">esm 原理</a></span></a></h3><p>一个模块的运行分为以下三步</p><ul><li>构建 <ul><li>查找下载，然后把所有文件解析成模块记录</li></ul></li><li>实例化 <ul><li>为每个模块记录分配内部所需的变量地址，以拥有状态</li></ul></li><li>运行</li></ul><p>如何实现以上步骤</p><ul><li>文件由加载器提取，（就是识别 esm 的方式）对于浏览器，标准是使用 html，type=module 的脚本，可由各个平台自定义</li><li>其他的步骤解析成模块记录和实例化和运行是由<a href="https://tc39.es/ecma262/#sec-modules" target="_blank" rel="noopener noreferrer">ESM</a>标准 规范</li></ul><p>ESM 和 CJS 之间最主要的区别之一就是，ESM 把算法化为为多个阶段。</p><ul><li>浏览器下载文件会耗费大量时间，会阻塞主线程，将构建分为一个独立阶段后，浏览器可以在进入同步的实例话过程前下载文件，理解模块关系图</li><li>动态导入实际上是将 import() 加载的文件当成了一个入口文件。动态导入的模块会开启一个全新的独立依赖关系树</li><li>加载器使用模块映射（Module Map）来管理缓存。每个全局作用域都在一个单独的模块映射中跟踪其模块。</li><li>采用实时绑定，值引用，引擎可以在不运行任何模块代码的情况下完成链接（不需要再执行代码获取值）</li></ul><h3 id="import-maps" tabindex="-1"><a class="header-anchor" href="#import-maps"><span><a href="https://beginor.github.io/2021/08/16/using-es-modules-in-borwser-with-importmaps.html" target="_blank" rel="noopener noreferrer">import-maps</a></span></a></h3><ul><li>通过 import-maps 可以让浏览器识别全局模块，</li><li>import-maps 使用 Json 的形式来定义浏览器中的全局模块</li><li>对于不支持 import-maps 的浏览器， 可以使用 es-module-shims 进行处理。</li></ul><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre class="language-html"><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>importmap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  <span class="token punctuation">{</span></span>
<span class="line">    <span class="token string-property property">&quot;importmap&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token string-property property">&quot;vue&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://unpkg.com/browse/vue@3.2.2/dist/vue.runtime.esm-browser.js&quot;</span><span class="token punctuation">,</span></span>
<span class="line">      <span class="token string-property property">&quot;vue-router&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://unpkg.com/browse/vue-router@4.0.11/dist/vue-router.esm-browser.js&quot;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  <span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">counter</span><span class="token operator">:</span> number <span class="token punctuation">}</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">&quot;#root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="es6-模块与-commonjs-模块的差异" tabindex="-1"><a class="header-anchor" href="#es6-模块与-commonjs-模块的差异"><span>ES6 模块与 CommonJS 模块的差异</span></a></h2><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。</li></ul><h3 id="es-module-总结" tabindex="-1"><a class="header-anchor" href="#es-module-总结"><span>es module 总结</span></a></h3><ul><li>静态的，不能放在块级作用域内，代码发生在编译时。在代码执行前会</li><li>导入模块在<strong>严格模式</strong>下。</li><li>esm 模块导出的常量是只读引用，如果尝试修改会报错</li><li>使用 esm 可以很容易实现 Tree Shaking 和 Code Splitting。</li><li>加载一个模块脚本时不需要使用 defer 属性 (see &lt;script&gt; attributes) 模块会自动延迟加载</li><li>执行顺序先子后父，采用深度优先的后序遍历的方式解析模块 tree</li><li>ES6 模块之中，顶层的 this 指向 undefined；CommonJS <strong>模块的顶层 this 指向当前模块</strong></li></ul><h3 id="循环加载" tabindex="-1"><a class="header-anchor" href="#循环加载"><span><a href="https://www.cnblogs.com/navysummer/p/9689858.html#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD" target="_blank" rel="noopener noreferrer">循环加载</a></span></a></h3><ul><li>commonJS 通过模块缓存的方式解决循环加载</li><li>ESM，先执行子模块代码，再回到父模块代码执行，如果子又引入了父模块，则认为父模块已经加载了，并且都是 undefined，如果是引入的函数，可以正常获得，因为函数声明提升</li></ul><p>## Systemjs</p><p>###  背景</p><p>使用 ESmodule 的 esmodule 的难点</p><ol><li><p>importmaps 的兼容性不够好，在 2023 年 3 月才在各大浏览器中支持</p></li><li><p>我们所有的 Javascript 文件都必须使用 ES Module 规范来声明，而我们现有的开发工作流中存在很多非 ES Module 规范的 JS 文件，导致我们的工作流无法整合，同时也面临兼容性问题。</p></li></ol><ul><li>SystemJS 的出现的初衷，可以实现在浏览器端实现对 CommonJS、AMD、UMD 等各种类型模块的加载，一个通用的模块加载器，使用 esmodule 的特性，实现了模块统一</li></ul><p>###  是什么</p><ul><li><p>systemJS 是一个模块加载标准，提供像原生 ES Modules 一样的开发工作流，webpack 已支持输出格式为 systemJS，</p><ul><li><p>我们可以在本地环境中使用 ES Module、CommonJS、UMD、AMD 模块规范进行开发，通过 Webpack 或 Babel，统一构建为 SystemJS Module 在运行环境中使用。</p><ul><li>解决部分包没有 esm 版本也能使用</li></ul></li></ul></li><li><p>利用 systemjs 可以使用 importmap、等 esm 的功能，性能上原生 ES Modules 几乎一样</p></li><li><p>兼容不支持原生 ES Modules 的老浏览器使用</p></li></ul><p>###  相关文档</p><ul><li><p><a href="https://segmentfault.com/a/1190000039305322" target="_blank" rel="noopener noreferrer">javascript - 差点被 SystemJs 惊掉了下巴，解密模块加载黑魔法 - 前端黑洞 - SegmentFault 思否</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/679232594" target="_blank" rel="noopener noreferrer">微前端核心系列（一）模块加载与 System.js - 知乎</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/402155045" target="_blank" rel="noopener noreferrer">SystemJS 探秘 - 知乎</a></p></li></ul><h2 id="打包配置" tabindex="-1"><a class="header-anchor" href="#打包配置"><span>打包配置</span></a></h2><p>了解了不同模块规范的用法，使用打包工具时就可以相应地指定模块规范。</p><h3 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack"><span>webpack</span></a></h3><p>webpack中，library是指定义一个全局使用的名称变量，libraryTarget是指设置library的暴露方式。配置见<a href="https://zhuanlan.zhihu.com/p/108216236" target="_blank" rel="noopener noreferrer">libraryTarget的几种选择我们来好好分析 - 知乎</a></p><p><img src="https://pic2.zhimg.com/80/v2-ee0dd359758d187d06abe280eb29f121_1440w.webp" alt=""></p><h3 id="rollup" tabindex="-1"><a class="header-anchor" href="#rollup"><span>rollup</span></a></h3><p>除了webpack，还有一些常见的模块打包器，比如rollup。它和webpack相比的特点是拥有更少的功能和更简单的api，适合一些简单的项目。</p><p>配置如下：</p><p>format支持amd、cjs、es、esm、iife和umd几种格式。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://github.com/muwoo/blogs/issues/28" target="_blank" rel="noopener noreferrer">CommonJS、AMD/CMD、ES6 Modules 以及 webpack 原理浅析</a> .</li><li><a href="https://www.html.cn/archives/6974" target="_blank" rel="noopener noreferrer">ES6 Modules(模块)系统及语法详解</a></li><li><a href="https://segmentfault.com/a/1190000014318751" target="_blank" rel="noopener noreferrer">esm 原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/108216236" target="_blank" rel="noopener noreferrer">libraryTarget的几种选择我们来好好分析 - 知乎</a></li><li><a href="https://juejin.cn/post/7185475655943847992" target="_blank" rel="noopener noreferrer">JS模块化之CommonJS、AMD、UMD和ESM规范 - 掘金</a></li></ul>`,53),l=[t];function o(i,c){return a(),n("div",null,l)}const u=s(p,[["render",o],["__file","模块化.html.vue"]]),d=JSON.parse('{"path":"/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96.html","title":"模块化","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"CommonJS","slug":"commonjs","link":"#commonjs","children":[{"level":3,"title":"exports 和 module.exports","slug":"exports-和-module-exports","link":"#exports-和-module-exports","children":[]}]},{"level":2,"title":"ESM","slug":"esm","link":"#esm","children":[{"level":3,"title":"esm 原理","slug":"esm-原理","link":"#esm-原理","children":[]},{"level":3,"title":"import-maps","slug":"import-maps","link":"#import-maps","children":[]}]},{"level":2,"title":"ES6 模块与 CommonJS 模块的差异","slug":"es6-模块与-commonjs-模块的差异","link":"#es6-模块与-commonjs-模块的差异","children":[{"level":3,"title":"es module 总结","slug":"es-module-总结","link":"#es-module-总结","children":[]},{"level":3,"title":"循环加载","slug":"循环加载","link":"#循环加载","children":[]}]},{"level":2,"title":"打包配置","slug":"打包配置","link":"#打包配置","children":[{"level":3,"title":"webpack","slug":"webpack","link":"#webpack","children":[]},{"level":3,"title":"rollup","slug":"rollup","link":"#rollup","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"updatedTime":1717633708000,"contributors":[{"name":"liujia6","email":"liujia11@qianxin.com","commits":1}]},"filePathRelative":"工程化/模块化.md"}');export{u as comp,d as data};
