import{_ as l,c as i,o as a,a as e}from"./app-B_HqqEoK.js";const t={},n=e('<h1 id="架构整洁之道" tabindex="-1"><a class="header-anchor" href="#架构整洁之道"><span>架构整洁之道</span></a></h1><p>架构：往往使用与高层级的讨论中，这类讨论一般都把底层的实现细节排除在外</p><p>设计：往往用来指代具体的系统底层组织结构和实现的细节</p><p>软件设计的底层设计细节和高层架构信息是不可分割的，他们组合在一起共同定义了整个软件系统，缺一不可。</p><p>对于每个软件系统，我们可以通过<strong>行为</strong>和<strong>架构</strong>两个维度来体现它的实际价值</p><ul><li>行为价值：业务逻辑</li><li>架构价值：系统架构的灵活性好则易于修改</li></ul><h3 id="编程范式" tabindex="-1"><a class="header-anchor" href="#编程范式"><span>编程范式</span></a></h3><p>编程范式是指程序的编写模式，与具体的变成语言关系较小。告诉你应该在什么时候采用什么样的代码结构。一共三个，而且未来几乎不可能再出现新的。</p><ol><li>结构化编程：对程序控制全的直接转移进行了限制和规范 <ol><li>功能性</li><li>限制 goto 语句</li></ol></li><li>面向对象编程：对程序控制权的简介转义进行了限制和规范 <ol><li>组件独立性</li><li>函数调用堆栈可以被挪到对内存区域里，函数定义域的本地变量就可以在函数返回之后继续存在，即成为类的构造函数。而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法。则可利用多态来限制用户对函数指针的使用。</li></ol></li><li>函数式编程：对程序中的赋值进行了限制和规范 <ol><li>数据管理</li><li>只有在非常严格的限制条件下，才可以更改某个变量的值</li></ol></li><li>响应式编程 <ol><li>响应式编程是一种面向数据流和变化传播的编程范式，旨在简化事件驱动应用的实现。响应式编程专注于如何创建依赖于变更的数据流并对变化做出响应。</li></ol></li></ol><h3 id="结构化编程" tabindex="-1"><a class="header-anchor" href="#结构化编程"><span>结构化编程</span></a></h3><p>认为程序员可以像数学家一样对自己的程序进行推理证明，人们可以用顺序结构、分支结构、循环结构这三种结构构造出任何程序，</p><ul><li>可推导性 <ul><li>促使我们先将一段程序递归讲解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的，然后再编写相关测试来试图证明这些函数是错误的。</li></ul></li><li>goto 是有害的</li><li>功能性降解拆分</li><li>形式化证明没有发生</li><li>数学公式基于推导，可以被证明。科学定律基于归纳，只能被证伪</li></ul><p>结构化编程赋予了我们创造可证伪程序单元的能力，在架构设计领域，功能性讲解拆分仍然是最佳实践之一。</p><h3 id="面向对象编程" tabindex="-1"><a class="header-anchor" href="#面向对象编程"><span>面向对象编程</span></a></h3><h2 id="ddd-领域驱动设计" tabindex="-1"><a class="header-anchor" href="#ddd-领域驱动设计"><span><a href="https://mp.weixin.qq.com/s/1kl8SV28GDt_40FF_6CuhA" target="_blank" rel="noopener noreferrer">DDD 领域驱动设计</a></span></a></h2><ul><li><p>目的</p><ul><li>业务优先 =&gt; 代码中业务逻辑一目了然，业务逻辑复用</li></ul></li><li><p>解决什么问题</p><ul><li>业务逻辑本身错综复杂，通过代码很难看出业务逻辑</li><li>团队无法形成统一逻辑代码书写规范，不规范的代码设计</li><li>忽略业务整体</li></ul></li></ul><h3 id="前端领域设计与结构分层" tabindex="-1"><a class="header-anchor" href="#前端领域设计与结构分层"><span>前端领域设计与结构分层</span></a></h3><p>回到前端开发的设计上，我们理解了上述讲解的业务领域的概念后，接着将其落实到前端开发中，我们重点需要理解的概念是 <code>职责分明，合理分层</code>，根据上述提出的“问题代码”，我们希望在前端结构设计中能做到：</p><ol><li><strong>视图层尽可能薄</strong>：获得的数据能够直接使用到视图层中，禁止在视图层中对数据进行转换、筛选、计算等逻辑操作。</li><li><strong>不写重复逻辑</strong>：遇到相同的逻辑尽可能复用而不是重写，逻辑函数尽可能写成可拓展可维护，暴露给团队其他成员。</li><li><strong>不同职责的代码进行分层</strong>：将不同职责代码合理分层，每层尽可能纯净，互不影响。</li><li><strong>前端字段不受后端影响</strong>：返回字段进行纠正，字段含义尽可能直观，在视图层使用时，能够更清晰地描述视图结构。</li><li><strong>可纵观全局领域</strong>：前端进行领域模块结构设计时，能够纵览整个项目下所有的领域，以及每个领域下具有的逻辑功能。</li></ol><p>结果：通过分层的领导思想，将数据操作等分层抽象出来，可清晰地看出业务逻辑，过滤掉接口请求等。有效地降低了项目的复杂度，分层的结构让各功能代码职责分明，在前端中将其业务逻辑代码逐一分层，与视图层解耦，做到了真正的业务逻辑复用，在代码的可读性、可维护性上也有了质的提升 <img src="https://mmbiz.qpic.cn/mmbiz_jpg/WtxTthEH6zewG4J5Gf3YhNe2tKYPNTic1niaB62JH2cJpiaf6uC3bEn7KkPEjfwG7d2VQmmtNQQddZ7tkXicLbArYw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="view-视图层-view" tabindex="-1"><a class="header-anchor" href="#view-视图层-view"><span>View 视图层 -&gt; view</span></a></h4><p>视图层也就是我们书写交互逻辑、样式的一层，可以使用纯 HTML 或者框架(React、Vue)，这一层只需要调用了领域的服务，将返回值直接体现在视图层中，无需编写条件判断、数据筛选、数据转换等与视图展示无关的逻辑代码，这些“糙活”都在其他层中以已经完成，所以视图层是非常“薄”的一层，只需关注视图的展示与交互，整个 HTML 结构非常直观清晰。</p><h4 id="领域层-domain" tabindex="-1"><a class="header-anchor" href="#领域层-domain"><span>领域层 -&gt; domain</span></a></h4><p>领域层是整个项目的核心层，它掌管了所有领域下的行为与定义，它是整个项目中最能体现业务知识的一层。</p><ul><li>entity：实体，是领域服务的载体，它定义了业务中某个个体的属性与方法，比如抽奖活动中的奖品、活动，这些都可以抽象为实体，它在全局领域中是唯一的，不可能在别的领域中存在相同的实体。</li><li>service：领域服务层，这一层中<strong>定义了领域的行为，供视图层直接调用</strong>。</li></ul><h4 id="数据接口层-data-source" tabindex="-1"><a class="header-anchor" href="#数据接口层-data-source"><span>数据接口层 data-source</span></a></h4><ul><li><p>requestApi：数据请求层，负责 http 请求，是项目中唯一与后端服务进行交流的一层。</p></li><li><p>translator：数据清洗层，这层负责将后端返回的数据“清洗”，改造成更直观地字段(key)、更方便使用的数据(value)。</p></li></ul>',27),s=[n];function r(o,p){return a(),i("div",null,s)}const h=l(t,[["render",r],["__file","架构整洁之道.html.vue"]]),c=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93.html","title":"架构整洁之道","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"编程范式","slug":"编程范式","link":"#编程范式","children":[]},{"level":3,"title":"结构化编程","slug":"结构化编程","link":"#结构化编程","children":[]},{"level":3,"title":"面向对象编程","slug":"面向对象编程","link":"#面向对象编程","children":[]},{"level":2,"title":"DDD 领域驱动设计","slug":"ddd-领域驱动设计","link":"#ddd-领域驱动设计","children":[{"level":3,"title":"前端领域设计与结构分层","slug":"前端领域设计与结构分层","link":"#前端领域设计与结构分层","children":[]}]}],"git":{"updatedTime":1720052070000,"contributors":[{"name":"liujia6","email":"liujia11@qianxin.com","commits":1}]},"filePathRelative":"编程/架构整洁之道.md"}');export{h as comp,c as data};
