(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{531:function(v,_,l){"use strict";l.r(_);var t=l(22),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),l("h2",{attrs:{id:"思想"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#思想"}},[v._v("#")]),v._v(" 思想")]),v._v(" "),l("ul",[l("li",[v._v("递归思想，看到一个题，就要去想能不能用递归写出来，找到共同的重复的步骤，找到递归结束的条件")]),v._v(" "),l("li",[v._v("归纳总结，看逻辑思想，尝试找出蕴含的数学知识")]),v._v(" "),l("li",[v._v("借助队列和栈")]),v._v(" "),l("li",[v._v("双指针,滑动窗口")]),v._v(" "),l("li",[v._v("先排序")]),v._v(" "),l("li",[v._v("回溯法：类似深度优先遍历，是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 回溯 并且再次尝试。")]),v._v(" "),l("li",[v._v("动态规划求解问题的几个特点：\n"),l("ul",[l("li",[v._v("求一个问题的最优解。（一般用 max 判断之前的结果获取最优）")]),v._v(" "),l("li",[v._v("整体问题的最优解是依赖各个子问题的最优解。")]),v._v(" "),l("li",[v._v("把大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题。")]),v._v(" "),l("li",[v._v("从上往下分析问题，从下往上求解问题。（子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取最大问题的最优解）。")])])])]),v._v(" "),l("h3",{attrs:{id:"动态规划和递归的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#动态规划和递归的区别"}},[v._v("#")]),v._v(" 动态规划和递归的区别")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("动态规划")]),v._v(" "),l("ul",[l("li",[v._v("将递归获得的值保存起来，比递归更好")]),v._v(" "),l("li",[v._v("是递归的优化解决方案")]),v._v(" "),l("li",[v._v("可以用一个数组或者值先存放当前状态下能找到的值，再在之后的每一次寻找中再与之比较")])])]),v._v(" "),l("li",[l("p",[v._v("回溯")]),v._v(" "),l("ul",[l("li",[v._v("将符合条件的值保存起来")])])]),v._v(" "),l("li",[l("p",[v._v("贪心算法")]),v._v(" "),l("ul",[l("li",[v._v("动态规划的特殊情况优化")])])])]),v._v(" "),l("p",[v._v("看到有两个数组而且需要联系这两个数组就用矩阵加上动态规划，找出前后之间的联系")])])}),[],!1,null,null,null);_.default=i.exports}}]);