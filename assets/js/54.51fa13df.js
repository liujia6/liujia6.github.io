(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{467:function(t,e,n){"use strict";n.r(e);var r=n(22),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"浏览器执行时间线"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浏览器执行时间线"}},[t._v("#")]),t._v(" 浏览器执行时间线：")]),t._v(" "),n("p",[t._v("根据js执行那一刻开始的执行顺序 浏览器加载的时间线")]),t._v(" "),n("p",[t._v("1.创建document对象，开始解析web页面 这时document.readyState 等于’loading’")]),t._v(" "),n("p",[t._v("2.遇到link标签（外部引用css）创建线程加载，并继续解析文档， 即异步加载")]),t._v(" "),n("p",[t._v("3.遇到非异步的script标签，浏览器加载并阻塞，等待js加载完成")]),t._v(" "),n("p",[t._v("4.遇到异步的script标签，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行；对于defer属性的脚本，脚本等到页面加载完之后再执行（异步禁止使用document.write）")]),t._v(" "),n("p",[t._v("5.遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档")]),t._v(" "),n("p",[t._v("6.当文档解析完成之后（即renderTree构建完成之后， 此时还未下载完对吧），document.readyState=‘interative’。活跃的 动态的")]),t._v(" "),n("p",[t._v("7.文档解析完成后，所有设置有defer的脚本会按照顺序执行。")]),t._v(" "),n("p",[t._v("8.文档解析完成之后 页面会触发document上的一个DOMContentLoad事件")]),t._v(" "),n("p",[t._v("9.当页面所有部分都执行完成之后 document.readyState =‘complete’ 之后就可以执行window.onload事件了")])])}),[],!1,null,null,null);e.default=a.exports}}]);