(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{487:function(e,o,t){"use strict";t.r(o);var v=t(22),a=Object(v.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"http"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[e._v("#")]),e._v(" HTTP")]),e._v(" "),t("ul",[t("li",[e._v("定义")]),e._v(" "),t("li",[e._v("超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本")])]),e._v(" "),t("h2",{attrs:{id:"http-0-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-0-9"}},[e._v("#")]),e._v(" HTTP/0.9")]),e._v(" "),t("ul",[t("li",[e._v("只支持 get 请求，响应为 html 文档格式的字符串")])]),e._v(" "),t("h2",{attrs:{id:"http-1-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[e._v("#")]),e._v(" HTTP/1.0")]),e._v(" "),t("ul",[t("li",[e._v("支持 get、post、head")]),e._v(" "),t("li",[e._v("包含基本的头信息、状态码等")]),e._v(" "),t("li",[e._v("支持各种数据类型")])]),e._v(" "),t("p",[e._v("头信息必须是 ASCII 码，后面的数据可以是任何格式")]),e._v(" "),t("p",[t("strong",[e._v("缺点：")])]),e._v(" "),t("ol",[t("li",[e._v("一个请求发送一个请求，之后连接就关闭。")]),e._v(" "),t("li",[e._v("connection：keep-alive 的设置不是标准字段，不同浏览器的实现不一致")])]),e._v(" "),t("h2",{attrs:{id:"http-1-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[e._v("#")]),e._v(" HTTP/1.1")]),e._v(" "),t("ul",[t("li",[e._v("tcp 连接默认不关闭\n"),t("ul",[t("li",[e._v("可以被多个请求复用，不用声明 connection：keep-alive，")]),e._v(" "),t("li",[e._v("客户端发现对方一段时间没有活动自动关闭 connection：close。规范的做法是在最后一个请求发送 connection：close")]),e._v(" "),t("li",[e._v("同一个域名，一般允许同时建立"),t("strong",[e._v("6")]),e._v("个持久连接")])])]),e._v(" "),t("li",[e._v("管道机制\n"),t("ul",[t("li",[e._v("在一个 tcp 连接里，客户端可以同时发送多个请求，不用等前面的收到回应再发送")]),e._v(" "),t("li",[e._v("content-length 字段声明本次回应的数据长度，区分数据包")])])]),e._v(" "),t("li",[e._v("分块传输编码\n"),t("ul",[t("li",[e._v("transfer-encoding：chunked 表示回应将由数量未定的数据块组成，取代 content-length")]),e._v(" "),t("li",[e._v("数据之前，16 进制数值表示块长度，最后大小为 0 的块表明本次传输完成")])])]),e._v(" "),t("li",[e._v("新的方法例如 put、patch、head、options、delete")]),e._v(" "),t("li",[e._v("host 头域：将请求发往同一台服务器上的不同网站")])]),e._v(" "),t("p",[t("strong",[e._v("缺点")])]),e._v(" "),t("ul",[t("li",[e._v("一个 tcp 连接的通信的服务器回应是按照次序进行的，要是有一个回应特别慢，会发生队头阻塞。")])]),e._v(" "),t("h2",{attrs:{id:"http-2-基于-spdy-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-2-基于-spdy-协议"}},[e._v("#")]),e._v(" HTTP/2:基于 SPDY 协议")]),e._v(" "),t("ul",[t("li",[e._v("二进制分帧\n"),t("ul",[t("li",[e._v('HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。')])])]),e._v(" "),t("li",[e._v("多路复用\n"),t("ul",[t("li",[e._v("客户端和服务端可以同时发送数据，不管顺序")])])]),e._v(" "),t("li",[e._v("服务端推送")]),e._v(" "),t("li",[e._v("头部压缩\n"),t("ul",[t("li",[e._v("头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。")])])])]),e._v(" "),t("p",[e._v("参考：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/08/http.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP 协议入门"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/wxisme/p/6212797.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("理解 HTTP 协议"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"cookie-和-localstorage-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-localstorage-区别"}},[e._v("#")]),e._v(" cookie 和 localstorage 区别")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Set-Cookie: <cookie-name>=<cookie-value>; Expires=<date> Set-Cookie: <cookie-name>=<cookie-value>; Max-Age=<non-zero-digit> Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value> Set-Cookie: <cookie-name>=<cookie-value>; Path=<path-value> Set-Cookie: <cookie-name>=<cookie-value>; Secure Set-Cookie: <cookie-name>=<cookie-value>;\n")])])]),t("p",[e._v("HttpOnly 如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的 key、domain、path 和 secure 都匹配。举例来说，如果原始的 Cookie 是用如下的 Set-Cookie 设置的。")]),e._v(" "),t("p",[e._v("Set-Cookie: key1=value1; domain=example.com; path=/blog")]),e._v(" "),t("p",[e._v("改变上面这个 Cookie 的值，就必须使用同样的 Set-Cookie。")]),e._v(" "),t("p",[e._v("Set-Cookie: key1=value2; domain=example.com; path=/blog")]),e._v(" "),t("p",[e._v("只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。")]),e._v(" "),t("p",[e._v("服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。")]),e._v(" "),t("ul",[t("li",[e._v("Cookie 的各种属性，比如何时过期。")]),e._v(" "),t("li",[e._v("哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。")])]),e._v(" "),t("p",[e._v("浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，http://example.com设置的 Cookie，可以被https://example.com读取。")]),e._v(" "),t("h2",{attrs:{id:"session-和-token-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#session-和-token-区别"}},[e._v("#")]),e._v(" session 和 token 区别")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("是 session 是"),t("strong",[e._v("后端保存")]),e._v("，会增加"),t("strong",[e._v("服务端")]),e._v("查询，保存数据的"),t("strong",[e._v("压力")]),e._v("，而且容易有"),t("strong",[e._v("CSRF")]),e._v("跨站伪造请求攻击，因为 sessionID 是存在 cookie 中的， cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。")])]),e._v(" "),t("li",[t("p",[e._v("token 是前端保存，比较灵活，可以实现单点登录而不受后端的限制；但是缺点也是不受后端控制，签发后不能撤销，只能通过建立黑名单再存储到数据库中")])]),e._v(" "),t("li",[t("p",[e._v("session 需要考虑分布式部署下 redis 数据库保存数据")])])]),e._v(" "),t("h2",{attrs:{id:"密码安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#密码安全"}},[e._v("#")]),e._v(" 密码安全")]),e._v(" "),t("ol",[t("li",[e._v("从信息安全的角度上不允许存储明文密码")]),e._v(" "),t("li",[e._v("加密方式")]),e._v(" "),t("li",[e._v("HAMC 加盐的方式")])]),e._v(" "),t("h3",{attrs:{id:"jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[e._v("#")]),e._v(" JWT")]),e._v(" "),t("p",[e._v("JWT 的最佳用途是「"),t("strong",[e._v("一次性授权 Token")]),e._v("」，这种场景下的 Token 的特性如下：\n有效期短，只希望被使用一次。\n例如分享一个文件给朋友，在指定 1 小时打开有效。")]),e._v(" "),t("p",[e._v("尽管这看上去像 cross-site scripting 攻击，结果并不会导致什么。HTML 5 中指定不执行由 innerHTML 插入的<script>标签。")]),e._v(" "),t("h4",{attrs:{id:"过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),t("p",[e._v("1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码\n2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个 token\n3、前端拿到 token，将 token 存储到 localStorage 和 vuex 中，并跳转路由页面（本项目根据是否记住密码来判断 token 存储到 sessionStorage 或 localStorage ）\n4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面\n5、每次调后端接口，都要在请求头中加 token\n6、后端判断请求头中有无 token，有 token，就拿到 token 并验证 token，验证成功就返回数据，验证失败（例如：token 过期）就返回 401，请求头中没有 token 也返回 401\n7、如果前端拿到状态码为 401，就清除 token 信息并跳转到登录页面")]),e._v(" "),t("h3",{attrs:{id:"webstorage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webstorage"}},[e._v("#")]),e._v(" WebStorage")]),e._v(" "),t("p",[t("strong",[e._v("生命周期")]),e._v("：sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。")]),e._v(" "),t("p",[e._v("cookie 机制：如果不在浏览器中设置过期时间，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，这种 cookie 简称会话 cookie。如果在浏览器中设置了 cookie 的过期时间，cookie 被保存在硬盘中，关闭浏览器后，cookie 数据仍然存在，直到过期时间结束才消失。")]),e._v(" "),t("p",[t("strong",[e._v("安全性")]),e._v("：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题；")]),e._v(" "),t("p",[e._v("HTML5 的本地存储 API 中的 localStorage 与 sessionStorage 在使用方法上是相同的，区别在于")]),e._v(" "),t("p",[e._v("Cookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时都带上它")]),e._v(" "),t("p",[t("strong",[e._v("存储内容")]),e._v("：cookie 只能保存字符串类型，以文本的方式；session 通过类似与 Hashtable 的数据结构来保存，能支持任何类型的对象(session 中可含有多个对象)")]),e._v(" "),t("p",[t("strong",[e._v("存储容量：cookie")]),e._v("为 4kb，localStorage 和 sessionStorage 的存储数据大小一般都是：5MB，")]),e._v(" "),t("p",[e._v("有些网站测试出来的不是整整的 5242880 （ 5120x1024 ），而是 5101k 之类的，我猜测应该是没把 key 算上，上面这个测试页面统计包含 key 的长度，所以很整齐，刚好 5120*1024，由此可知 key 也是算容量的 localstorage 的容量每个浏览器都不一样，都是在 5MB 左右，关于单位问题，单位是字符，可以是中文或英文字母，一个中文等同一个英文字母。所以有些地方说是容量是 10M，也不能算错。因为 js 用 utf-16，所以中文英文一个字符都是是 2 个字节，10M 指的是字节数。")]),e._v(" "),t("p",[t("strong",[e._v("存储位置")]),e._v("：localStorage 和 sessionStorage 都保存在客户端，不与服务器进行交互通信，节省了网络流量，而且显示更快。而 cookie 每次访问都要传送 cookie 给服务器")]),e._v(" "),t("p",[e._v("其他请求头：")]),e._v(" "),t("p",[e._v("origin：跨域的判断")]),e._v(" "),t("p",[e._v("referer：防盗链")])])}),[],!1,null,null,null);o.default=a.exports}}]);