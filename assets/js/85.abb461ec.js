(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{496:function(v,_,t){"use strict";t.r(_);var a=t(22),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"架构整洁之道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#架构整洁之道"}},[v._v("#")]),v._v(" 架构整洁之道")]),v._v(" "),t("p",[v._v("架构：往往使用与高层级的讨论中，这类讨论一般都把底层的实现细节排除在外")]),v._v(" "),t("p",[v._v("设计：往往用来指代具体的系统底层组织结构和实现的细节")]),v._v(" "),t("p",[v._v("软件设计的底层设计细节和高层架构信息是不可分割的，他们组合在一起共同定义了整个软件系统，缺一不可。")]),v._v(" "),t("p",[v._v("对于每个软件系统，我们可以通过"),t("strong",[v._v("行为")]),v._v("和"),t("strong",[v._v("架构")]),v._v("两个维度来体现它的实际价值")]),v._v(" "),t("ul",[t("li",[v._v("行为价值：业务逻辑")]),v._v(" "),t("li",[v._v("架构价值：系统架构的灵活性好则易于修改")])]),v._v(" "),t("h3",{attrs:{id:"编程范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编程范式"}},[v._v("#")]),v._v(" 编程范式")]),v._v(" "),t("p",[v._v("编程范式是指程序的编写模式，与具体的变成语言关系较小。告诉你应该在什么时候采用什么样的代码结构。一共三个，而且未来几乎不可能再出现新的。")]),v._v(" "),t("ol",[t("li",[v._v("结构化编程：对程序控制全的直接转移进行了限制和规范\n"),t("ol",[t("li",[v._v("功能性")]),v._v(" "),t("li",[v._v("限制 goto 语句")])])]),v._v(" "),t("li",[v._v("面向对象编程：对程序控制权的简介转义进行了限制和规范\n"),t("ol",[t("li",[v._v("组件独立性")]),v._v(" "),t("li",[v._v("函数调用堆栈可以被挪到对内存区域里，函数定义域的本地变量就可以在函数返回之后继续存在，即成为类的构造函数。而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法。则可利用多态来限制用户对函数指针的使用。")])])]),v._v(" "),t("li",[v._v("函数式编程：对程序中的赋值进行了限制和规范\n"),t("ol",[t("li",[v._v("数据管理")]),v._v(" "),t("li",[v._v("只有在非常严格的限制条件下，才可以更改某个变量的值")])])]),v._v(" "),t("li",[v._v("响应式编程\n"),t("ol",[t("li",[v._v("响应式编程是一种面向数据流和变化传播的编程范式，旨在简化事件驱动应用的实现。响应式编程专注于如何创建依赖于变更的数据流并对变化做出响应。")])])])]),v._v(" "),t("h3",{attrs:{id:"结构化编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构化编程"}},[v._v("#")]),v._v(" 结构化编程")]),v._v(" "),t("p",[v._v("认为程序员可以像数学家一样对自己的程序进行推理证明，人们可以用顺序结构、分支结构、循环结构这三种结构构造出任何程序，")]),v._v(" "),t("ul",[t("li",[v._v("可推导性\n"),t("ul",[t("li",[v._v("促使我们先将一段程序递归讲解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的，然后再编写相关测试来试图证明这些函数是错误的。")])])]),v._v(" "),t("li",[v._v("goto 是有害的")]),v._v(" "),t("li",[v._v("功能性降解拆分")]),v._v(" "),t("li",[v._v("形式化证明没有发生")]),v._v(" "),t("li",[v._v("数学公式基于推导，可以被证明。科学定律基于归纳，只能被证伪")])]),v._v(" "),t("p",[v._v("结构化编程赋予了我们创造可证伪程序单元的能力，在架构设计领域，功能性讲解拆分仍然是最佳实践之一。")]),v._v(" "),t("h3",{attrs:{id:"面向对象编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程"}},[v._v("#")]),v._v(" 面向对象编程")]),v._v(" "),t("h2",{attrs:{id:"ddd-领域驱动设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ddd-领域驱动设计"}},[v._v("#")]),v._v(" "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s/1kl8SV28GDt_40FF_6CuhA",target:"_blank",rel:"noopener noreferrer"}},[v._v("DDD 领域驱动设计"),t("OutboundLink")],1)]),v._v(" "),t("ul",[t("li",[t("p",[v._v("目的")]),v._v(" "),t("ul",[t("li",[v._v("业务优先 => 代码中业务逻辑一目了然，业务逻辑复用")])])]),v._v(" "),t("li",[t("p",[v._v("解决什么问题")]),v._v(" "),t("ul",[t("li",[v._v("业务逻辑本身错综复杂，通过代码很难看出业务逻辑")]),v._v(" "),t("li",[v._v("团队无法形成统一逻辑代码书写规范，不规范的代码设计")]),v._v(" "),t("li",[v._v("忽略业务整体")])])])]),v._v(" "),t("h3",{attrs:{id:"前端领域设计与结构分层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端领域设计与结构分层"}},[v._v("#")]),v._v(" 前端领域设计与结构分层")]),v._v(" "),t("p",[v._v("回到前端开发的设计上，我们理解了上述讲解的业务领域的概念后，接着将其落实到前端开发中，我们重点需要理解的概念是 "),t("code",[v._v("职责分明，合理分层")]),v._v("，根据上述提出的“问题代码”，我们希望在前端结构设计中能做到：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("视图层尽可能薄")]),v._v("：获得的数据能够直接使用到视图层中，禁止在视图层中对数据进行转换、筛选、计算等逻辑操作。")]),v._v(" "),t("li",[t("strong",[v._v("不写重复逻辑")]),v._v("：遇到相同的逻辑尽可能复用而不是重写，逻辑函数尽可能写成可拓展可维护，暴露给团队其他成员。")]),v._v(" "),t("li",[t("strong",[v._v("不同职责的代码进行分层")]),v._v("：将不同职责代码合理分层，每层尽可能纯净，互不影响。")]),v._v(" "),t("li",[t("strong",[v._v("前端字段不受后端影响")]),v._v("：返回字段进行纠正，字段含义尽可能直观，在视图层使用时，能够更清晰地描述视图结构。")]),v._v(" "),t("li",[t("strong",[v._v("可纵观全局领域")]),v._v("：前端进行领域模块结构设计时，能够纵览整个项目下所有的领域，以及每个领域下具有的逻辑功能。")])]),v._v(" "),t("p",[v._v("结果：通过分层的领导思想，将数据操作等分层抽象出来，可清晰地看出业务逻辑，过滤掉接口请求等。有效地降低了项目的复杂度，分层的结构让各功能代码职责分明，在前端中将其业务逻辑代码逐一分层，与视图层解耦，做到了真正的业务逻辑复用，在代码的可读性、可维护性上也有了质的提升\n"),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/WtxTthEH6zewG4J5Gf3YhNe2tKYPNTic1niaB62JH2cJpiaf6uC3bEn7KkPEjfwG7d2VQmmtNQQddZ7tkXicLbArYw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),v._v(" "),t("h4",{attrs:{id:"view-视图层-view"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#view-视图层-view"}},[v._v("#")]),v._v(" View 视图层 -> view")]),v._v(" "),t("p",[v._v("视图层也就是我们书写交互逻辑、样式的一层，可以使用纯 HTML 或者框架(React、Vue)，这一层只需要调用了领域的服务，将返回值直接体现在视图层中，无需编写条件判断、数据筛选、数据转换等与视图展示无关的逻辑代码，这些“糙活”都在其他层中以已经完成，所以视图层是非常“薄”的一层，只需关注视图的展示与交互，整个 HTML 结构非常直观清晰。")]),v._v(" "),t("h4",{attrs:{id:"领域层-domain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#领域层-domain"}},[v._v("#")]),v._v(" 领域层 -> domain")]),v._v(" "),t("p",[v._v("领域层是整个项目的核心层，它掌管了所有领域下的行为与定义，它是整个项目中最能体现业务知识的一层。")]),v._v(" "),t("ul",[t("li",[v._v("entity：实体，是领域服务的载体，它定义了业务中某个个体的属性与方法，比如抽奖活动中的奖品、活动，这些都可以抽象为实体，它在全局领域中是唯一的，不可能在别的领域中存在相同的实体。")]),v._v(" "),t("li",[v._v("service：领域服务层，这一层中"),t("strong",[v._v("定义了领域的行为，供视图层直接调用")]),v._v("。")])]),v._v(" "),t("h4",{attrs:{id:"数据接口层-data-source"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据接口层-data-source"}},[v._v("#")]),v._v(" 数据接口层 data-source")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("requestApi：数据请求层，负责 http 请求，是项目中唯一与后端服务进行交流的一层。")])]),v._v(" "),t("li",[t("p",[v._v("translator：数据清洗层，这层负责将后端返回的数据“清洗”，改造成更直观地字段(key)、更方便使用的数据(value)。")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);