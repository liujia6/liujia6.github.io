import{_ as e,c as a,o as t,a as l}from"./app-BsmYACjM.js";const p={},i=l('<h1 id="tcp-和-udp" tabindex="-1"><a class="header-anchor" href="#tcp-和-udp"><span>TCP 和 UDP</span></a></h1><h2 id="tcp-和-udp-的区别" tabindex="-1"><a class="header-anchor" href="#tcp-和-udp-的区别"><span>TCP 和 UDP 的区别</span></a></h2><p>是传输层最常用的两种不同类型的协议，负责把应用层的数据报文传输给网络层。</p><ul><li><p>TCP 是面向连接和字节流的，将数据看成无结构的字节流，在发送方和接收方建立一个连接，实现全双工一对一的通信。在这个通信过程中通过一系列控制例如超时重传，拥塞控制，流量控制等保证传输过程的可靠性。适合对于准确性要求高或者要求有连接并且对效率要求低的场景</p></li><li><p>UDP 是面向报文的，将应用层传来的报文加上 UDP 的首部后直接传输给网络层，没有任何控制和可靠性的保证措施，适合对于效率要求高且准确性要求低的场景</p></li><li><p><a href="https://vue3js.cn/interview/http/UDP_TCP.html#%E4%B8%89%E3%80%81%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">面试官：如何理解 UDP 和 TCP? 区别? 应用场景? | web 前端面试 - 面试官系列</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/64155705" target="_blank" rel="noopener noreferrer">TCP 协议详解 - 知乎</a></p></li><li><p><a href="https://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener noreferrer">TCP 协议简介 - 阮一峰的网络日志</a></p></li><li><p><a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md" target="_blank" rel="noopener noreferrer">Front-End-Interview-Notebook/计算机网络/计算机网络.md at master · CavsZhouyou/Front-End-Interview-Notebook</a></p></li></ul><h2 id="描述下-tcp3-次握手与-tcp4-次挥手-以及为什么要-3-次和-4-次" tabindex="-1"><a class="header-anchor" href="#描述下-tcp3-次握手与-tcp4-次挥手-以及为什么要-3-次和-4-次"><span>描述下 TCP3 次握手与 TCP4 次挥手，以及为什么要 3 次和 4 次</span></a></h2><p><img src="https://img1.sycdn.imooc.com//5d01c4d20001cc8e09600720.jpg" alt="sd"></p><h3 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手"><span>三次握手</span></a></h3><p>三次握手主要是为了确认双方的收发功能都正常并且确认</p><p><img src="https://pic1.zhimg.com/80/v2-576b043d12353928eea6e45373655668_720w.webp?source=1def8aca" alt="sa"></p><ul><li><p>第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的 随机数。它代表的是客户端数据的初始序号。</p></li><li><p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向 客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认， 同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号 加一。</p></li><li><p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。</p></li></ul><h3 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手"><span>四次挥手</span></a></h3><p><img src="https://pica.zhimg.com/80/v2-c8b61ed2a249700583b11bc5d16c5711_720w.webp?source=1def8aca" alt=""></p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li></ul><h4 id="为什么需要4次挥手" tabindex="-1"><a class="header-anchor" href="#为什么需要4次挥手"><span>为什么需要4次挥手</span></a></h4><p>服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手</p><h4 id="为什么客户端最后需要等待一会" tabindex="-1"><a class="header-anchor" href="#为什么客户端最后需要等待一会"><span>为什么客户端最后需要等待一会</span></a></h4><p>确保最后一个 ACK 报文能够到达对方：在 TIME_WAIT 状态下，如果最后一次发送的 ACK 报文丢失，对方会因为没有收到确认而重新发送 FIN 报文。处于 TIME_WAIT 状态的一方能够重新发送 ACK。所以客户端最后会启动一个计时器，如果在时间内发现服务端重发了报文，需要重新发送报文，以此确保连接的可靠关闭。</p><ul><li><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></li><li><p><a href="https://segmentfault.com/a/1190000020610336" target="_blank" rel="noopener noreferrer">tcp - 面试官，不要再问我三次握手和四次挥手 - 猿人谷 - SegmentFault 思否</a></p></li></ul>',18),r=[i];function n(c,o){return t(),a("div",null,r)}const h=e(p,[["render",n],["__file","UDP.html.vue"]]),d=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C/TCP/UDP.html","title":"TCP 和 UDP","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"TCP 和 UDP 的区别","slug":"tcp-和-udp-的区别","link":"#tcp-和-udp-的区别","children":[]},{"level":2,"title":"描述下 TCP3 次握手与 TCP4 次挥手，以及为什么要 3 次和 4 次","slug":"描述下-tcp3-次握手与-tcp4-次挥手-以及为什么要-3-次和-4-次","link":"#描述下-tcp3-次握手与-tcp4-次挥手-以及为什么要-3-次和-4-次","children":[{"level":3,"title":"三次握手","slug":"三次握手","link":"#三次握手","children":[]},{"level":3,"title":"四次挥手","slug":"四次挥手","link":"#四次挥手","children":[]}]}],"git":{"updatedTime":1717633708000,"contributors":[{"name":"liujia6","email":"liujia11@qianxin.com","commits":1}]},"filePathRelative":"网络/TCP/UDP.md"}');export{h as comp,d as data};
