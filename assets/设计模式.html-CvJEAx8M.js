import{_ as n,c as s,o as a,a as p}from"./app-CVfBBX0w.js";const e={},t=p(`<h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h1><h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则"><span>设计原则</span></a></h2><ul><li>开闭原则 <ul><li>添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性等)，而非修改已有代码(修改模块、类、方法、属性等)的方式来完成 <ul><li>✅ 新增函数，扩展开放</li><li>❎ 修改原函数，修改关闭</li></ul></li><li>可以理解各种库（vue、webpack）都提供插件来增强其功能</li></ul></li><li>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li><li><a href="https://cloud.tencent.com/developer/article/1831005" target="_blank" rel="noopener noreferrer">里氏替换原则</a><ul><li>定义： 子类在被父类完全替换时，代码功能不会变化。 <ul><li>要实现以上功能需要保证子类只扩展了父类的功能，尽量少通过重载修改，或者是使用抽象方法定义子类的实现</li><li>也就是说在使用继承时，只扩展新功能，而不要重载</li></ul></li><li>优点 <ul><li>减少继承带来的缺点，增强程序的健壮性，版本升级时也可以保持良好的兼容性。即使增加子类，原有的子类也可以继续运行。</li><li>只有当子类可以替换掉父类,软件单位的功能不受到影响时，父类才能真正的被复用</li><li>使得开放-封闭成为可能</li></ul></li><li>如何修改 <ul><li>当违反该原则时，当下的继承关系实际是不合适的 <ul><li>将原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</li></ul></li></ul></li></ul></li><li><a href="https://juejin.cn/post/6844904117173747726" target="_blank" rel="noopener noreferrer">依赖倒置原则</a> （DIP） <ul><li>总纲：面向接口编程</li><li>定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象</li><li>设计模式的应用 <ul><li>模板方法模式：使用该设计模式意味着子类放弃了对自己的控制权，而是改为父类通知子类。作为子类，只负责提供一些设计上的细节。</li><li>观察者模式：发布者把消息推送给订阅者。</li><li>回调函数：ajax 异步请求，把需要执行的操作封装在回调函数里，当数据返回后，这个回调函数才被执行。</li></ul></li><li>IOC 与 DI <ul><li>依赖反转是遵守依赖倒置这个原则而提出来的一种设计模式，它引入了 IoC 容器的概念。</li><li><strong>控制反转</strong>（IOC）是设计模式，遵从了依赖倒置原则，它引入了 IoC 容器的概念。在外部 IoC 容器内将依赖注入（在依赖注入的概念中叫注射器）</li><li><strong>依赖注入</strong>（DI）是实现控制反转的手段：不通过 new（）的方式在类内部创建对象</li><li>实现依赖注入有 3 种方式 <ul><li>构造函数中注入</li><li>setter 方式注入</li><li>接口注入</li></ul></li><li><a href="https://time.geekbang.org/column/article/177444" target="_blank" rel="noopener noreferrer">参考</a></li></ul></li><li>框架定义抽象接口让使用时面向接口实现即可，库只会提供工具方法</li></ul></li><li><a href="https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/" target="_blank" rel="noopener noreferrer">迪米特法则：又名“最少知道原则“</a><ul><li>定义：一个对象应该对其他对象保持最少对了解</li><li>解决了什么问题：尽量降低类与类之间对耦合，实现高内聚，低耦合</li><li>一个类对自己以来对自己依赖的类知道的越少越好，只与必要的对象交互</li><li><a href="https://juejin.cn/post/6872985439117312014" target="_blank" rel="noopener noreferrer">理解</a>：病人给护士交钱，那么护士应该与病人交互，而不是与钱包交互，在这里，病人是护士和钱包的中介者</li><li>如果你发现你的代码中有getXXX().getXXX().getXXX()……类似于这种代码，那就考虑下是不是违反迪米特法则，是不是要重构一下了</li><li>设计模式的应用 <ul><li>中介者模式：降低多个对象和类之间的通信复杂度，处理类之间的通信，支持松耦合，使代码易于维护，属于行为模式</li></ul></li></ul></li><li>接口隔离原则：客户端不应依赖它不需要的接口 interface 方法。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法</li></ul><h2 id="高内聚、低耦合" tabindex="-1"><a class="header-anchor" href="#高内聚、低耦合"><span>高内聚、低耦合</span></a></h2><ul><li>耦合 <ul><li>两个模块之间如果能够独立工作，则这两个模块之间无耦合，如果两个模块是相互依赖的，则这两个模块之间有耦合</li><li>例子 <ul><li>例如 vue 组件中我们可以使用 emit 一个事件告知父组件，父组件可以通过$emit 来接收 <ul><li>这里通过 emit 事件降低了父子组件的耦合，事件属于组件本身的属性，我们不需要知道父组件的结构，只需要知道父组件的事件名称，相比直接调用父组件的方法，事件的耦合性更低</li></ul></li></ul></li><li>若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。</li></ul></li><li>内聚 <ul><li>高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。所有内部状态和功能都是为了达到该组件的逻辑功能，提高程序的可靠性</li></ul></li><li>如何降低耦合，提高内聚</li></ul><h2 id="设计模式-1" tabindex="-1"><a class="header-anchor" href="#设计模式-1"><span>设计模式</span></a></h2><h3 id="提高代码复用性的模式" tabindex="-1"><a class="header-anchor" href="#提高代码复用性的模式"><span>提高代码复用性的模式</span></a></h3><h4 id="享元模式-共享来减少数量" tabindex="-1"><a class="header-anchor" href="#享元模式-共享来减少数量"><span>享元模式-共享来减少数量</span></a></h4><ul><li>当我们观察到代码中有大量相似的代码块，他们做的事情可能都是一样的，只是每次应用的对象不一样，以减少重复代码</li></ul><h4 id="桥接模式-独立出来-然后再对接过去" tabindex="-1"><a class="header-anchor" href="#桥接模式-独立出来-然后再对接过去"><span>桥接模式-独立出来，然后再对接过去</span></a></h4><ul><li>桥接模式是将重复的逻辑按照逻辑将其抽离出来一个新的方法构造原对象 <ul><li>将重复代码拆成多个维度（多个方法），使用时再组合，以减少重复代码</li></ul></li></ul><h4 id="模板方法模式-主要点在于抽象出公共的步骤-用函数式的写法就相当于传入一个有固定方法的类" tabindex="-1"><a class="header-anchor" href="#模板方法模式-主要点在于抽象出公共的步骤-用函数式的写法就相当于传入一个有固定方法的类"><span><a href="https://juejin.cn/post/7057026037477015583" target="_blank" rel="noopener noreferrer">模板方法模式</a> （主要点在于抽象出公共的步骤），用函数式的写法就相当于传入一个有固定方法的类</span></a></h4><p>模板方法模式 就是对同一种类型的事务，总结出他们共同的执行步骤。<strong>是 DI 的一种实现</strong></p><ul><li>定义抽象行为步骤</li><li>实现固定的抽象步骤执行</li><li>具体类 extends 基础行为类，实现抽象行为步骤即可生成一个新的对象</li></ul><h3 id="🍅-创建型" tabindex="-1"><a class="header-anchor" href="#🍅-创建型"><span><a href="http://dennisgo.cn/Articles/DesignPatterns/Encapsulate.html" target="_blank" rel="noopener noreferrer">🍅 创建型</a></span></a></h3><h4 id="工厂模式-大量创建对象" tabindex="-1"><a class="header-anchor" href="#工厂模式-大量创建对象"><span><a href="https://github.com/hzlu/JS-design-pattern/tree/master/factory-pattern" target="_blank" rel="noopener noreferrer">工厂模式-大量创建对象</a></span></a></h4><ul><li>对不同类对创建隐藏，我们只需要对工厂下订单，并不需要知道获取对具体类是什么</li><li>☝️ 代码准则 <ul><li>当有多种同类型的类。我们可以把她们的创建过程封装，使其 create 使用更加简单</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">function</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> content<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">popup</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">this</span><span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">popup</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> content<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  popup<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">infoPopup</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  popup<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">confirmPopup</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  popup<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">cancelPopup</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  window<span class="token punctuation">.</span>popup <span class="token operator">=</span> popup<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 外面就直接可以使用popup模块了</span></span>
<span class="line"><span class="token keyword">let</span> infoPopup1 <span class="token operator">=</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token string">&#39;infoPopup&#39;</span><span class="token punctuation">,</span> content<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="单例模式-全局只能有我一个-融入了日常代码中" tabindex="-1"><a class="header-anchor" href="#单例模式-全局只能有我一个-融入了日常代码中"><span>单例模式-全局只能有我一个（融入了日常代码中）</span></a></h4><p>用一个变量来标记代码是否已经执行过了，如果执行过了就返回上次的执行结果，这样就保证了多次调用也会拿到一样的结果。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">let</span> _Vue<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">install</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>install<span class="token punctuation">.</span>installed <span class="token operator">&amp;&amp;</span> _Vue <span class="token operator">===</span> Vue<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  install<span class="token punctuation">.</span>installed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  _Vue <span class="token operator">=</span> Vue<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="建造者模式-精细化组合对象-融入了日常代码中" tabindex="-1"><a class="header-anchor" href="#建造者模式-精细化组合对象-融入了日常代码中"><span>建造者模式-精细化组合对象（融入了日常代码中）</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">function</span> <span class="token function">Model1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 模块1</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">Model2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 模块2</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 最终使用的类</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">Final</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>model1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Model1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>model2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Model2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 使用时</span></span>
<span class="line"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Final</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="原型模式-javascript-的灵魂-融入了日常代码中" tabindex="-1"><a class="header-anchor" href="#原型模式-javascript-的灵魂-融入了日常代码中"><span>原型模式-javaScript 的灵魂（融入了日常代码中）</span></a></h4><p>原型模式最典型的应用就是 JS 本身啊，JS 的原型链就是原型模式。JS 中可以使用 Object.create 指定一个对象作为原型来创建对象:</p><h3 id="提高代码质量-代码整洁度" tabindex="-1"><a class="header-anchor" href="#提高代码质量-代码整洁度"><span>提高代码质量，代码整洁度</span></a></h3><h4 id="状态模式-用状态代替判断" tabindex="-1"><a class="header-anchor" href="#状态模式-用状态代替判断"><span>状态模式-用状态代替判断</span></a></h4><ul><li>常见用例 <ul><li>promise 的两种状态，状态机</li></ul></li><li>复杂情况下对不同状态以及状态之间的转变进行定义，可以提高代码的质量，清晰度</li></ul><h4 id="策略模式-算法工厂" tabindex="-1"><a class="header-anchor" href="#策略模式-算法工厂"><span>策略模式-算法工厂</span></a></h4><ul><li>就是将分支判断变为对象内的函数引用，对不同对情况使用对象进行封装使得逻辑更加清晰</li></ul><h4 id="外观模式-给你的一个套餐-融入了日常代码中-封装" tabindex="-1"><a class="header-anchor" href="#外观模式-给你的一个套餐-融入了日常代码中-封装"><span>外观模式-给你的一个套餐（融入了日常代码中-封装）</span></a></h4><ul><li>就像 jquery 处理了浏览器的兼容性，提供一个统一简洁且易用的 API</li><li>☝️ 代码准则 <ul><li>当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用及其复杂。通过外观模式，对接口进行二次封装可以隐藏其复杂性。</li></ul></li></ul><h3 id="行为发送与处理者不同连接" tabindex="-1"><a class="header-anchor" href="#行为发送与处理者不同连接"><span>行为发送与处理者不同连接</span></a></h3><ul><li>提高代码扩展性</li></ul><p>责任链模式 (opens new window)、 命令模式 (opens new window)、 中介者模式 (opens new window) 和 观察者模式 (opens new window)用于处理请求发送者和接收者之间的不同连接方式</p><ul><li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li><li>命令在发送者和请求者之间建立单向连接。对请求信息更好得封装</li><li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li><li>观察者允许接收者动态地订阅或取消接收请求。</li></ul><h4 id="职责链模式-像生产线一样组织模块-流水线" tabindex="-1"><a class="header-anchor" href="#职责链模式-像生产线一样组织模块-流水线"><span><a href="https://juejin.cn/post/6854573219400122376#heading-1" target="_blank" rel="noopener noreferrer">职责链模式</a>-像生产线一样组织模块 （流水线）</span></a></h4><p>类似于错误处理的方式，和中间件、<a href="http://dennisgo.cn/Articles/DesignPatterns/Extendability.html" target="_blank" rel="noopener noreferrer">axios 请求拦截器 filter</a></p><p>一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点</p><h5 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h5><ul><li>当程序需要使用不同方式处理<strong>不同种类请求</strong>， 而且<strong>请求类型和顺序预先未知</strong>时， 可以使用责任链模式。</li><li>当必须<strong>按顺序执行</strong>多个处理者时， 可以使用该模式。</li><li>如果<strong>所需处理者及其顺序必须在运行时进行改变</strong>， 可以使用责任链模式。</li></ul><h4 id="命令模式-是对行为-函数-的一种封装" tabindex="-1"><a class="header-anchor" href="#命令模式-是对行为-函数-的一种封装"><span><a href="https://juejin.cn/post/6844903615253970951#heading-0" target="_blank" rel="noopener noreferrer">命令模式</a> - 是对行为（函数）的一种封装</span></a></h4><p>命令模式是一种基础模式，本意是对行为（函数）的一种封装，将行为封装为对象，以使得后续任意处理者可以了解该行为并对该行为做更多复杂的行为处理。例如对记录请求排队或者记录请求日志，以及执行可撤销的操作。</p><ul><li>该模式在 JS 中是一种隐身模式，常用的高阶函数就是一种命令模式</li><li>☝️ 代码准则 <ul><li>当某个函数（动作）的功能具有较多的信息记录，可以将其封装为一个高阶函数，或者对象记录其相关信息并传递给处理者</li></ul></li></ul><h4 id="观察者模式-我作为第三方转发" tabindex="-1"><a class="header-anchor" href="#观察者模式-我作为第三方转发"><span>观察者模式-我作为第三方转发</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">var</span> Observer<span class="token operator">=</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;I&#39;m watching you&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">var</span> Subject<span class="token operator">=</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">observers</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">            item<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token function">attach</span><span class="token punctuation">(</span><span class="token parameter">observer</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="发布订阅模式" tabindex="-1"><a class="header-anchor" href="#发布订阅模式"><span>发布订阅模式</span></a></h4><p>在实际使用中，我们应该也会接触到 PubSub 模式，例如 Nodejs 中的 EventEmitter、Backbone 中的事件模型、以及 jQuery 中的事件。 以 EventEmitter 为栗子，它提供了 addListener(event, listener)，removeListener(event, listener)，emit(event, [arg1], [arg2], [...]) 方法。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">var</span> pubSub<span class="token operator">=</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">topics</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        topics<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">?</span>topics<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">++</span><span class="token operator">:</span>topics<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token function">publish</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        topic<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">item</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="观察者与发布订阅的区别" tabindex="-1"><a class="header-anchor" href="#观察者与发布订阅的区别"><span>观察者与发布订阅的区别</span></a></h5><ul><li>观察者模式中主体和观察者是两者之间直接传递消息，发布-订阅模式是借助第三方来实现消息传递的，发布者和订阅者之间互不感知</li></ul><p><img src="https://user-images.githubusercontent.com/18718461/53536375-228ba180-3b41-11e9-9737-d71f85040cfc.png" alt="image"></p><h2 id="其他技巧" tabindex="-1"><a class="header-anchor" href="#其他技巧"><span>其他技巧</span></a></h2><h4 id="适配器模式-用适配代替更改" tabindex="-1"><a class="header-anchor" href="#适配器模式-用适配代替更改"><span>适配器模式-用适配代替更改</span></a></h4><p>当我们面临接口不通用，接口参数不匹配等情况，我们可以在他外面再包一个方法，这个方法接收我们现在的名字和参数，里面调用老方法传入以前的参数形式。</p><h4 id="装饰者模式-更优雅地扩展需求" tabindex="-1"><a class="header-anchor" href="#装饰者模式-更优雅地扩展需求"><span>装饰者模式 - 更优雅地扩展需求</span></a></h4><p>装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。例如 window.onload。ES7 中的装饰器语法</p><h4 id="组合模式" tabindex="-1"><a class="header-anchor" href="#组合模式"><span><a href="https://juejin.cn/post/6995851145490989070" target="_blank" rel="noopener noreferrer">组合模式</a></span></a></h4><ul><li><p>定义</p><ul><li>是一种<strong>统一管理树形结构</strong>的抽象方式。有点类似与树形结构的递归处理</li><li>将对象组合成树形结构以表示 “部分 - 整体” 的层次结构</li><li>Composite 使得用户对单个对象和组合对象的使用具有一致性。</li></ul></li><li><p>例子</p><ul><li><p>操作系统的文件夹与文件</p><p>操作系统的文件夹与文件也是典型的树状结构，为了方便递归出文件夹内文件数量或者文件总大小，我们最好设计的时候就将文件夹与文件抽象为文件，这样每个节点都拥有相同的方法添加、删除、查找子元素，而不需要关心当前节点是文件夹或是文件。</p></li></ul></li><li><p>用职责链模式提高组合模式性能</p><ul><li>在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。</li></ul></li><li><p>优势</p><ul><li>组合模式使客户可以忽略组合对象和叶对象的区别 <ul><li>客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。</li></ul></li><li>组合模式可以方便地构造一棵树来表示对象的部分——整体结构。 <ul><li>特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放——封闭原则。</li></ul></li></ul></li><li><p>劣势</p><ul><li>组合模式进行了一层抽象，其实增加了复杂系统中业务复杂度。如果 <code>Composite</code> 与 <code>Leaf</code> 差异过大，那么统一抽象带来的理解成本是很高的。</li><li>同时，<code>Leaf</code> 不得不实现一些仅 <code>Composite</code> 存在的空函数，比如 <code>add</code> <code>delete</code>，即便这些方法对他们是无意义的，此时可能要进行统一的无效或错误处理，才能使业务层真正不用感知他们的区别，否则 <code>add</code> 可能会失败，其本质上还是将节点的区别暴露给了业务层。</li></ul></li><li><p>组合模式是针对树状结构这个特定场景的统一抽象方案，对降低系统复杂度有很重要的意义，同时也不要忘了过度抽象是有害的，我们要拿捏其中的度。</p></li></ul><h4 id="中介者模式-降低耦合性" tabindex="-1"><a class="header-anchor" href="#中介者模式-降低耦合性"><span>中介者模式 - 降低耦合性</span></a></h4><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。</p><ul><li>通过中介类，我们简单地传入我们的需求与自身状态，执行我们需求功能，减少与外部类之间的耦合</li><li>缺点是需要维护一个中介者对象，增加交互的复杂性</li><li>☝️ 代码准则 <ul><li>当我们与另一个类交互时，需要抽出方法</li></ul></li></ul><h2 id="aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#aop-面向切面编程"><span>AOP 面向切面编程</span></a></h2><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">around</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> beforeFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> _fn <span class="token operator">=</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">_fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token function">beforeFn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token function">_fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token function">before</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> beforeFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> _fn <span class="token operator">=</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token function">beforeFn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token function">_fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token function">after</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> beforeFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> _fn <span class="token operator">=</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token function">_fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token function">beforeFn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="http://dennisgo.cn/Articles/DesignPatterns/DesignPatterns.html" target="_blank" rel="noopener noreferrer">设计模式</a></li></ul>`,66),l=[t];function i(c,o){return a(),s("div",null,l)}const r=n(e,[["render",i],["__file","设计模式.html.vue"]]),k=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"设计模式","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"设计原则","slug":"设计原则","link":"#设计原则","children":[]},{"level":2,"title":"高内聚、低耦合","slug":"高内聚、低耦合","link":"#高内聚、低耦合","children":[]},{"level":2,"title":"设计模式","slug":"设计模式-1","link":"#设计模式-1","children":[{"level":3,"title":"提高代码复用性的模式","slug":"提高代码复用性的模式","link":"#提高代码复用性的模式","children":[]},{"level":3,"title":"🍅 创建型","slug":"🍅-创建型","link":"#🍅-创建型","children":[]},{"level":3,"title":"提高代码质量，代码整洁度","slug":"提高代码质量-代码整洁度","link":"#提高代码质量-代码整洁度","children":[]},{"level":3,"title":"行为发送与处理者不同连接","slug":"行为发送与处理者不同连接","link":"#行为发送与处理者不同连接","children":[]}]},{"level":2,"title":"其他技巧","slug":"其他技巧","link":"#其他技巧","children":[]},{"level":2,"title":"AOP 面向切面编程","slug":"aop-面向切面编程","link":"#aop-面向切面编程","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"updatedTime":1717649313000,"contributors":[{"name":"Liu Jia","email":"41950983+liujia6@users.noreply.github.com","commits":1}]},"filePathRelative":"编程/设计模式.md"}');export{r as comp,k as data};
