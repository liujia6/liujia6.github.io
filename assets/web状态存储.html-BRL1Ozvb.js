import{_ as e,c as o,o as t,a}from"./app-B_HqqEoK.js";const i={},s=a(`<h1 id="web状态存储" tabindex="-1"><a class="header-anchor" href="#web状态存储"><span>web状态存储</span></a></h1><h2 id="cookie-和-localstorage-区别" tabindex="-1"><a class="header-anchor" href="#cookie-和-localstorage-区别"><span>cookie 和 localstorage 区别</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt; Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt; Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt; Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt; Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>HttpOnly 如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的 key、domain、path 和 secure 都匹配。举例来说，如果原始的 Cookie 是用如下的 Set-Cookie 设置的。</p><p>Set-Cookie: key1=value1; domain=example.com; path=/blog</p><p>改变上面这个 Cookie 的值，就必须使用同样的 Set-Cookie。</p><p>Set-Cookie: key1=value2; domain=example.com; path=/blog</p><p>只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。</p><p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。</p><ul><li>Cookie 的各种属性，比如何时过期。</li><li>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。</li></ul><p>浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，http://example.com设置的 Cookie，可以被https://example.com读取。</p><h2 id="session-和-token-区别" tabindex="-1"><a class="header-anchor" href="#session-和-token-区别"><span>session 和 token 区别</span></a></h2><ul><li><p>是 session 是<strong>后端保存</strong>，会增加<strong>服务端</strong>查询，保存数据的<strong>压力</strong>，而且容易有<strong>CSRF</strong>跨站伪造请求攻击，因为 sessionID 是存在 cookie 中的， cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li><li><p>token 是前端保存，比较灵活，可以实现单点登录而不受后端的限制；但是缺点也是不受后端控制，签发后不能撤销，只能通过建立黑名单再存储到数据库中</p></li><li><p>session 需要考虑分布式部署下 redis 数据库保存数据</p></li></ul><h2 id="密码安全" tabindex="-1"><a class="header-anchor" href="#密码安全"><span>密码安全</span></a></h2><ol><li>从信息安全的角度上不允许存储明文密码</li><li>加密方式</li><li>HAMC 加盐的方式</li></ol><h3 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt"><span>JWT</span></a></h3><p>JWT 的最佳用途是「<strong>一次性授权 Token</strong>」，这种场景下的 Token 的特性如下： 有效期短，只希望被使用一次。 例如分享一个文件给朋友，在指定 1 小时打开有效。</p><p>尽管这看上去像 cross-site scripting 攻击，结果并不会导致什么。HTML 5 中指定不执行由 innerHTML 插入的&lt;script&gt;标签。</p><h4 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h4><p>1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码 2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个 token 3、前端拿到 token，将 token 存储到 localStorage 和 vuex 中，并跳转路由页面（本项目根据是否记住密码来判断 token 存储到 sessionStorage 或 localStorage ） 4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面 5、每次调后端接口，都要在请求头中加 token 6、后端判断请求头中有无 token，有 token，就拿到 token 并验证 token，验证成功就返回数据，验证失败（例如：token 过期）就返回 401，请求头中没有 token 也返回 401 7、如果前端拿到状态码为 401，就清除 token 信息并跳转到登录页面</p><h3 id="webstorage" tabindex="-1"><a class="header-anchor" href="#webstorage"><span>WebStorage</span></a></h3><p><strong>生命周期</strong>：sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。</p><p>cookie 机制：如果不在浏览器中设置过期时间，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，这种 cookie 简称会话 cookie。如果在浏览器中设置了 cookie 的过期时间，cookie 被保存在硬盘中，关闭浏览器后，cookie 数据仍然存在，直到过期时间结束才消失。</p><p><strong>安全性</strong>：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题；</p><p>HTML5 的本地存储 API 中的 localStorage 与 sessionStorage 在使用方法上是相同的，区别在于</p><p>Cookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时都带上它</p><p><strong>存储内容</strong>：cookie 只能保存字符串类型，以文本的方式；session 通过类似与 Hashtable 的数据结构来保存，能支持任何类型的对象(session 中可含有多个对象)</p><p><strong>存储容量：cookie</strong>为 4kb，localStorage 和 sessionStorage 的存储数据大小一般都是：5MB，</p><p>有些网站测试出来的不是整整的 5242880 （ 5120x1024 ），而是 5101k 之类的，我猜测应该是没把 key 算上，上面这个测试页面统计包含 key 的长度，所以很整齐，刚好 5120*1024，由此可知 key 也是算容量的 localstorage 的容量每个浏览器都不一样，都是在 5MB 左右，关于单位问题，单位是字符，可以是中文或英文字母，一个中文等同一个英文字母。所以有些地方说是容量是 10M，也不能算错。因为 js 用 utf-16，所以中文英文一个字符都是是 2 个字节，10M 指的是字节数。</p><p><strong>存储位置</strong>：localStorage 和 sessionStorage 都保存在客户端，不与服务器进行交互通信，节省了网络流量，而且显示更快。而 cookie 每次访问都要传送 cookie 给服务器</p><p>其他请求头：</p><p>origin：跨域的判断</p><p>referer：防盗链</p>`,33),l=[s];function n(r,c){return t(),o("div",null,l)}const k=e(i,[["render",n],["__file","web状态存储.html.vue"]]),g=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C/web%E7%8A%B6%E6%80%81%E5%AD%98%E5%82%A8.html","title":"web状态存储","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"cookie 和 localstorage 区别","slug":"cookie-和-localstorage-区别","link":"#cookie-和-localstorage-区别","children":[]},{"level":2,"title":"session 和 token 区别","slug":"session-和-token-区别","link":"#session-和-token-区别","children":[]},{"level":2,"title":"密码安全","slug":"密码安全","link":"#密码安全","children":[{"level":3,"title":"JWT","slug":"jwt","link":"#jwt","children":[]},{"level":3,"title":"WebStorage","slug":"webstorage","link":"#webstorage","children":[]}]}],"git":{"updatedTime":1720052070000,"contributors":[{"name":"liujia6","email":"liujia11@qianxin.com","commits":1}]},"filePathRelative":"网络/web状态存储.md"}');export{k as comp,g as data};
