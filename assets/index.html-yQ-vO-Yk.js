import{_ as l,c as e,o as i,a}from"./app-BsmYACjM.js";const t={},r=a('<h1 id="算法" tabindex="-1"><a class="header-anchor" href="#算法"><span>算法</span></a></h1><h2 id="思想" tabindex="-1"><a class="header-anchor" href="#思想"><span>思想</span></a></h2><ul><li>递归思想，看到一个题，就要去想能不能用递归写出来，找到共同的重复的步骤，找到递归结束的条件。通常树的问题可以用递归解决。树本身就是一个递归的结构</li><li>归纳总结，看逻辑思想，尝试找出蕴含的数学知识</li><li>栈 <ul><li>单调栈：栈中只存储单调递增的数据，或者单调递减的数据</li></ul></li><li>双指针,滑动窗口</li><li>先排序</li><li>回溯法 <ul><li>定义:是一种深度优先搜索的暴力遍历所有解法的算法，它基于递归，可以思考原问题的解是可以由子问题的解得出，通常可以将遍历看成一颗n叉树，通过判断条件，去除不需要的遍历。</li><li>问题的特点 <ul><li>递归遍历</li><li>深度优先搜索的n叉树</li></ul></li></ul></li><li>动态规划 <ul><li>定义：在递归计算过程中，由于子问题计算有可能重复计算，浪费资源，因此可以从最小的子问题开始计算，由子问题得出父问题的答案，所有问题都只需要算一遍。</li><li>适合场景：动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。</li><li>特点 <ul><li>子问题是相互依赖的，在分解过程中会出现许多重叠子问题。</li><li>最优子结构：原问题的最优解是从子问题的最优解构建得来的</li><li>无后效性：给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关。 <ul><li>许多复杂的组合优化问题（例如旅行商问题）不满足无后效性。对于这类问题，我们通常会选择使用其他方法，例如启发式搜索、遗传算法、强化学习等，从而在有限时间内得到可用的局部最优解。</li></ul></li></ul></li></ul></li></ul><h3 id="动态规划和递归的区别" tabindex="-1"><a class="header-anchor" href="#动态规划和递归的区别"><span>动态规划和递归的区别</span></a></h3><ul><li><p>动态规划</p><ul><li>将递归获得的值保存起来，比递归更好</li><li>是递归的优化解决方案</li><li>可以用一个数组或者值先存放当前状态下能找到的值，再在之后的每一次寻找中再与之比较</li></ul></li><li><p>回溯</p><ul><li>将符合条件的值保存起来</li></ul></li><li><p>贪心算法</p><ul><li>动态规划的特殊情况优化</li></ul></li></ul><p>看到有两个数组而且需要联系这两个数组就用矩阵加上动态规划，找出前后之间的联系</p><h3 id="相关参考" tabindex="-1"><a class="header-anchor" href="#相关参考"><span>相关参考</span></a></h3><ul><li><a href="https://www.hello-algo.com/chapter_hello_algo/" target="_blank" rel="noopener noreferrer">序 - Hello 算法</a></li><li><a href="https://github.com/sisterAn/JavaScript-Algorithms" target="_blank" rel="noopener noreferrer">sisterAn/JavaScript-Algorithms: 基础理论+JS框架应用+实践，从0到1构建整个前端算法体系</a></li><li><a href="https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md" target="_blank" rel="noopener noreferrer">codeforces-go/leetcode/SOLUTIONS.md at master · EndlessCheng/codeforces-go</a></li></ul>',8),n=[r];function o(s,c){return i(),e("div",null,n)}const d=l(t,[["render",o],["__file","index.html.vue"]]),u=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/","title":"算法","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"思想","slug":"思想","link":"#思想","children":[{"level":3,"title":"动态规划和递归的区别","slug":"动态规划和递归的区别","link":"#动态规划和递归的区别","children":[]},{"level":3,"title":"相关参考","slug":"相关参考","link":"#相关参考","children":[]}]}],"git":{"updatedTime":1717633708000,"contributors":[{"name":"liujia6","email":"liujia11@qianxin.com","commits":1}]},"filePathRelative":"算法/README.md"}');export{d as comp,u as data};
